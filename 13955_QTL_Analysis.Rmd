---
title: "NC13955 QTL Analysis Script"
author: "Zach Winn"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Library and write Function for R/qtl formatting

```{r}
# Load necessary libraries
library(gaston)
library(tidyverse)
library(asreml)
library(ASMap)
library(qtl)
library(psych)
library(knitr)
library(ggplot2)
library(patchwork)

# Write Brian's function
format_qtlmap_geno <- function(
                               bed, # A 'bed' formatted file (from the function gaston::read.vcf()) 
                               par_a, # Name of parent A (must be listed in bed file IDs)
                               par_b, # Name of parent B (must be listed in bed file IDs)
                               rm_het = TRUE, # If you want heterozygous calls removed
                               rm_miss = TRUE, # If you want missing data removed
                               include_pars = TRUE, # If you want to include the parents in the final dataframe
                               out_fmt = "rqtl" # What type of output you want to make 
                               ) {
  ### Sanity Checks ###
  # If parent a is not found in the bed file
  if (!(par_a %in% bed@ped$id)) {
    # Then throw error and stop
    stop("Parent A is not present in supplied bed matrix")
  }
  # If parent b is not found in the bed file 
  if (!(par_b %in% bed@ped$id)) {
    # Then throw error and stop
    stop("Parent B is not present in supplied bed matrix")
  }
  # If rm_het, rm_miss, and include_pars are not logical arguments
  if (!(is.logical(rm_het) & is.logical(rm_miss) & is.logical(include_pars))) {
    # Then throw error and stop
    stop("rm_het, rm_miss, and include_pars must be TRUE or FALSE")
  }
  # If the output format listed is not icimapping nor rqtl
  if (!(out_fmt %in% c("icimapping", "rqtl"))) {
    # Then throw error and stop
    stop("Please select either 'icimapping' or 'rqtl' for out_fmt")
  }

  # Make a new dataframe from the bed matrix 
  genomat <- as.data.frame(t(gaston::as.matrix(bed)))
  
  # Create new dataframe from genomat that is called "parents:
  parents <- data.frame(
    snp = rownames(genomat), # Name of the snps
    a = genomat[[par_a]], # Parent A genotype
    b = genomat[[par_b]], # Parent B genotype
    stringsAsFactors = FALSE # Make sure the strings are not factors
  )
  
  # Sum the parent haplotypes
  parents$sum <- parents$a + parents$b

  # Make a null object called drop_snps
  drop_snps <- NULL
  
  # Pull the union of SNPs that are the same between the parents
  drop_snps <- union(drop_snps, parents$snp[parents$a == parents$b])
  
  # If the user has indicated to remove hets
  if (rm_het) {
    # Then add those to the list of snps to drop
    drop_snps <- union(drop_snps, parents$snp[parents$a == 1 | parents$b == 1])
  } else {
    # Drop the snps where one parent is het and the other is missing
    drop_snps <- union(drop_snps, parents$snp[is.na(parents$a) & parents$b == 1])
    drop_snps <- union(drop_snps, parents$snp[parents$a == 1 & is.na(parents$b)])
  }
  
  # If the user has indicated to remove missing data
  if (rm_miss) {
    # Then add those markers with missing data in either parents to the list
    drop_snps <- union(drop_snps, parents$snp[is.na(parents$a) | is.na(parents$b)])
  } else {
    # Drop the snps where one parent has missing data to reduce ambiguity
    drop_snps <- union(drop_snps, parents$snp[is.na(parents$a) & is.na(parents$b)])
  }

  # Drop snps from genomat that are in drop_snps
  genomat <- genomat[!rownames(genomat) %in% drop_snps, ]
  
  # Do this for the bed file as well
  bed@snps <- bed@snps[!bed@snps$id %in% drop_snps, ]

  # Make an object of the snps where parent a is the minor allele 
  flip <- parents$snp[parents$a == 2]
  
  # Get a list of snps that are equal to zero for parent b and the sum is incalculable
  flip <- union(flip, parents$snp[is.na(parents$sum) & parents$b == 0])
  
  # Get a list of snps that are equal to 0 in the b parent and the sum is 1
  flip <- union(flip, parents$snp[parents$sum == 1 & parents$b == 0])
  
  # Drop any NAs from the flip vector
  flip <- flip[!is.na(flip)]

  # Any marker feautred in the flip vector will be turned into the parent A call
  genomat[flip, ] <- genomat[flip, ] - 2
  
  # We then take the absolute value so that |0-2|=2 for what was the major allele for the B parent
  genomat <- abs(genomat)

  # If the user indicated that they want to keep the parents in the resulting output
  if (include_pars) {
    # Make a vector of the names of all others in the population
    colorder <- setdiff(colnames(genomat), c(par_a, par_b))
    
    # Make a vector for column order so that the parents show up at the front
    colorder <- c(par_a, par_b, colorder)
    
    # Order the genotyping matrix as such
    genomat <- genomat[colorder]
  } else {
    # Get rid of both parents in the genotyping matrix
    genomat[c(par_a, par_b)] <- NULL
  }

  # Make a new column called id in the genotyping matrix
  genomat$id <- rownames(genomat)

  # If the user wants a genotyping matrix in the format acceptable to icimapping
  if (out_fmt == "icimapping") {
    # Then subtract everything by 1 so that the matrix is c(-1,0,1) coded
    genomat[is.na(genomat)] <- -1
    
    # Pull the id, chromosome, position, ref and alt alleles from the bed matrix
    id_df <- bed@snps[c("id", "chr", "dist", "pos", "A1", "A2")]
    
    # Merge that with the final output
    out_df <- merge(id_df, genomat, by = "id")
  } else {
    # Code 0 as A
    genomat[genomat == 0] <- "A"
    
    # Code 2 as B
    genomat[genomat == 2] <- "B"
    
    # Code 1 as H
    genomat[genomat == 1] <- "H"
    
    # Code NA as -
    genomat[is.na(genomat)] <- "-"
    
    # Make a new dataframe with id, chromosome, and dist
    id_df <- bed@snps[c("id", "chr", "dist")]
    
    # merge that with genomat
    out_df <- merge(id_df, genomat, by = "id")
    
    # make empty spaces
    names(out_df)[2:3] <- ""
  }
  
  # make an outlist of the genotyping matrix and a vector of the markers that were flipped 
  out_list <- list(abh = out_df, flipped = flip)
  
  # Return that output to the user
  return(out_list)
}
```

# Read in phenotypic data

```{r}
# Read in data
pheno <- read.csv("NC13955_Combined_Data_Final.csv")

# Read in potential selfs
selfs <- read.csv("list_of_potential_selfs.csv")

# Remove selfs
pheno <- pheno %>%
  filter(!GENOTYPE %in% selfs$GENOTYPE)

# Ensure the correct data types
pheno[, 1:7] <- lapply(pheno[, 1:7], as.factor)
pheno[, 8:ncol(pheno)] <- lapply(pheno[, 8:ncol(pheno)], as.numeric)
```

# Calculate BLUEs within and across environments

```{r}
# Set up lists for loop
env <- levels(pheno$ENV)
traits <- colnames(pheno)[8:12]

# Create dataframe for means output
BLUEs_loc <- data.frame(GENOTYPE = unique(pheno$GENOTYPE))

# Run models for each environment
for (i in env) {
  for (j in traits) {
    # Print message
    print_message <- paste("### Analyzing", j, "in", i, "###")
    print(paste(rep("#", nchar(print_message)), collapse = ""))
    print(print_message)
    print(paste(rep("#", nchar(print_message)), collapse = ""))
    
    # Read subset of phenotype data
    pheno_subset <- na.omit(pheno[pheno$ENV == i, c("GENOTYPE", "REP", j)])
    colnames(pheno_subset)[3] <- "Y"
    
    # Check if subset is empty
    if (nrow(na.omit(pheno_subset)) == 0) {
      # Throw message
      print(paste("###", j, "not taken in", i, "moving on..."))
      remove(pheno_subset)
      next
    }
    
    # If the trait is abnormally distributed
    if (j %in% c("FHB", "FDK", "DON")) {
      # Run model and pull estimates
      fit <- asreml(fixed = Y ~ GENOTYPE,
                    random = ~ REP,
                    residual = ~ units,
                    data = pheno_subset,
                    family = asr_poisson(),
                    maxit = 75)
      
      # Check if model converges and if it results in critial error, default to RCBD with normal distribution
      if (fit$converge == FALSE | (i == "WAR20" & j == "FHB")) {
        # Fit model
        fit <- asreml(fixed = Y ~ GENOTYPE,
                      random = ~ REP,
                      residual = ~ units,
                      data = pheno_subset,
                      maxit = 75)
        # Update model
        fit <- update.asreml(fit)
      }
      
      # Get quick summary (comment out for markdown) 
      # print(summary(fit))
      # print(plot(fit))
      
      # Pull BLUEs
      pred <- predict(fit, classify = "GENOTYPE", maxit = 75)$pvals[, c("GENOTYPE", "predicted.value")]
      
      # Rename
      colnames(pred)[2] <- paste(j, "_", i, sep = "")
      
      # Bind
      BLUEs_loc <- left_join(BLUEs_loc, pred, by = "GENOTYPE")
    } else {
      # Run model and pull estimates 
      fit <- asreml(fixed = Y ~ GENOTYPE,
                    random = ~ REP,
                    residual = ~ units,
                    data = pheno_subset)
      
      # Get quick summary (comment out for markdown) 
      # print(summary(fit))
      # print(plot(fit))
      
      # Get BLUEs
      pred <- predict(fit, classify = "GENOTYPE")$pvals[, c("GENOTYPE", "predicted.value")]
      
      # Rename
      colnames(pred)[2] <- paste(j, "_", i, sep = "")
      
      # Bind
      BLUEs_loc <- left_join(BLUEs_loc, pred, by = "GENOTYPE")      
    }
    # Remove temporary objects
    remove(pheno_subset, fit, pred)
  }
}
```

# Multi-environmental models

```{r}
# Define traits
traits <- colnames(pheno)[8:12]

# Create dataframe for predictions
BLUEs_mem <- data.frame(GENOTYPE = unique(pheno$GENOTYPE))

# Run MEMLM loop for each trait
for (i in traits) {
  
  # Print message
  print_message <- paste("### Analyzing", i, "###")
  print(paste(rep("#", nchar(print_message)), collapse = ""))
  print(print_message)
  print(paste(rep("#", nchar(print_message)), collapse = ""))
  
  # Subset data
  pheno_subset <- na.omit(pheno[, c("GENOTYPE", "YEAR", "ENV", "REP", i)])
  
  # Redefine data types
  pheno_subset[, 1:4] <- lapply(pheno_subset[, 1:4], as.factor)
  pheno_subset[, 5] <- as.numeric(pheno_subset[, 5])
  colnames(pheno_subset)[5] <- "Y"
  
  # Run mixed effects model
  if (i %in% c("FHB", "FDK", "DON")) {
    # Fit model with Poisson distribution
    fit <- asreml(fixed = Y ~ GENOTYPE,
                  random = ~ REP:ENV + GENOTYPE:ENV,
                  residual = ~ units,
                  data = pheno_subset,
                  family = asr_poisson(),
                  maxit = 75)
    
  } else {
    # Fit model with normal distribution
    fit <- asreml(fixed = Y ~ GENOTYPE,
                  random = ~ REP:ENV + GENOTYPE:ENV,
                  residual = ~ units,
                  data = pheno_subset,
                  #family = asr_poisson(),
                  maxit = 75)
      
  }
  
  # Get quick summary (comment out for markdown) 
  # print(summary(fit))
  # print(plot(fit))

  # Get predictions
  pred <- predict(fit, classify = "GENOTYPE")$pvals[, 1:2]
  colnames(pred)[2] <- paste(i, "ME", sep = "_") 
  
  # Left join predictions to main dataframe
  BLUEs_mem <- left_join(BLUEs_mem, pred, by = "GENOTYPE")
  
  # Remove temporary objects
  remove(pheno_subset, fit, pred)
}

# Select specific traits from the results
BLUEs_mem <- BLUEs_mem %>%
  select(GENOTYPE, FHB_ME, FDK_ME, DON_ME, HD_ME, PH_ME)
```

# Heritabilities

```{r}
# Make an empty data frame for the heritability estimates
h2s <- data.frame(Trait = character(), 
                  Type = character(), 
                  Estimation = numeric(), 
                  SE = numeric())

# Calculate the harmonic means for each trait
e_traits <- list()
r_traits <- list()

for (j in traits) {
  # Subset data and only take complete case
  a <- pheno %>% 
    drop_na(all_of(j))
  
  # Get the number of observations per genotype
  obs_per_ind <- aggregate(a[, j] ~ GENOTYPE, 
                           data = a,
                           length)
  
  # Calculate the harmonic mean of replications
  r <- (1 / mean(1 / obs_per_ind$`a[, j]`))
  
  # Put that in an object
  r_traits[j] <- r
  
  # Create a new object called e
  e <- c()
  
  # For every genotype in the phenotypic dataset 
  for (i in unique(pheno$GENOTYPE)) {
    # Get every observation in every environment
    a <- na.omit(pheno[pheno$GENOTYPE == i, c("ENV", j)])
    
    # Get get the number of environments that the genotype was observed in
    a <- length(unique(a$ENV))
    
    # If the number of environments equals 0, then 0, if it is greater than that, do 1 / number of environments
    a <- ifelse(a == 0, 0, 1 / a)
    
    # Add this value to the vector e
    e <- rbind(e, a)
  }
  
  # Take the reciprocal of the value e to get the harmonic mean of environments
  e_traits[j] <- (1 / mean(e)) 
  
  # Remove all the little things
  remove(a, obs_per_ind, r, e)
}

# Loop through each trait for heritability estimation
for (i in traits) {
  # Print message
  print_message <- paste("### Analyzing", i, "###")
  print(paste(rep("#", nchar(print_message)), collapse = ""))
  print(print_message)
  print(paste(rep("#", nchar(print_message)), collapse = ""))
  
  # Determine number of locations
  n_loc <- pheno %>% 
    select(ENV, YEAR, LOC, all_of(i)) %>% 
    drop_na() %>% 
    distinct(ENV)
  n_loc <- as.numeric(nrow(n_loc))
  
  # Determine the number of replications
  n_rep <- n_loc * 2
  
  # Determin the number of years
  n_year <- pheno %>% 
    select(ENV, YEAR, LOC, all_of(i)) %>% 
    drop_na() %>% 
    distinct(YEAR)
  n_year <- as.numeric(count(n_year))
  
  # Get the harmonic mean of environments
  e <- as.numeric(e_traits[i])
  
  # Get the harmonic mean of replications
  r <- as.numeric(r_traits[i])
  
  # If the trait has been observed over many years
  if (n_year >= 2) {
    # If the trait is a disease reaction trait
    if (i %in% c("FHB", "FDK", "DON")) {
      # Run model for Poisson distributed traits
      mlm <- asreml(fixed = pheno[, i] ~ 1,
                    random = ~ GENOTYPE +
                      ENV +
                      GENOTYPE:ENV,
                    residual = ~ idv(units),
                    data = pheno,
                    maxit = 75,
                    family = asr_poisson())
    } else {
      # Run model for normally distributed traits
      mlm <- asreml(fixed = pheno[, i] ~ 1,
                    random = ~ (GENOTYPE) +
                      ENV +
                      GENOTYPE:ENV,
                    residual = ~ idv(units),
                    data = pheno,
                    maxit = 75)
    }
  # If the trait has been only observed in one year
  } else {
    # Run model for single year data
    mlm <- asreml(fixed = pheno[, i] ~ 1,
                  random = ~ (GENOTYPE) +
                    ENV +
                    GENOTYPE:ENV,
                  residual = ~ idv(units),
                  data = pheno,
                  maxit = 75)
  }
  
  # Print summary of variance components
  print(summary(mlm)$varcomp)
  
  # Predict heritability estimates
  pph2 <- vpredict(mlm, 
                   h2 ~ V2 / (V2 + V3 + V4))
  
  emh2 <- vpredict(mlm,
                   h2 ~ V2 / (V2 + (V3 / e) + (V4 / (e * r))))
  
  # Bind predictions to h2s data frame
  a <- rbind(pph2, emh2)
  a <- cbind(data.frame(Trait = c(i, i)), data.frame(Type = c("Per-Plot", "Entry-Mean")), a)
  h2s <- rbind(h2s, a)
  
  # Remove the little things
  remove(mlm, pph2, emh2, n_loc, n_rep, n_year, e, r, a)
}

# Write heritability out
write.csv(h2s,
          "heritability.csv",
          row.names = FALSE)
```

# Make the rQTL file

```{r}
# Read in genetic information from VCF file
geno <- read.vcf("NC13-20076xGA06493-13LE6_filt.vcf.gz", convert.chr = FALSE)

# Plot lack of coverage in geno
check <- as.data.frame(as.matrix(geno))
check <- data.frame(SNP = colnames(check),
                    Chromosome = stringr::str_sub(colnames(check), start = 2, end = 3),
                    Position = stringr::str_sub(colnames(check), start = 5))

ggplot(check, aes(y = Chromosome, x = as.numeric(Position)/1000000)) +
  geom_point()+
  labs(title = "Marker Coverage",
       x = "Position (Mbp)")

# Convert genotype matrix to format suitable for rqtl
geno <- format_qtlmap_geno(geno, 
                            par_a = "13955-GA06493-13LE6",
                            par_b = "13955-NC13-20076",
                            rm_het = TRUE, 
                            rm_miss = TRUE, 
                            include_pars = TRUE, 
                            out_fmt = "rqtl")$abh

# Replace heterozygous calls with missing data
geno <- replace(geno, geno == "H", "-")

# Manipulate the genetic file to match rqtl's format requirements
geno <- as.data.frame(t(geno))
colnames(geno) <- geno[1, ]
geno <- geno[-1, ]
geno <- cbind(substr(gsub("[.]", "-", rownames(geno)), start = 2, stop = nchar(rownames(geno))), geno)
rownames(geno) <- NULL
geno <- rownames_to_column(geno, var = "dummy")  # Create a dummy column to sort later on
geno$dummy <- as.numeric(geno$dummy)
colnames(geno)[2] <- "GENOTYPE"
geno[1:2, 2] <- ""

# Merge all the BLUEs
BLUEs_all <- left_join(BLUEs_mem, BLUEs_loc, by = "GENOTYPE")

# Write out BLUEs_all
write.csv(BLUEs_all,
          "blues_across_and_within_environment.csv",
          row.names = FALSE)

# Make and write out summary 
BLUEs_all_summary <- data.frame(unclass(summary(BLUEs_all[, 2:ncol(BLUEs_all)])), check.names = FALSE, stringsAsFactors = FALSE)
rownames(BLUEs_all_summary) <- c("Minimum", "First Quantile", "Median", "Mean", "Third Quantile", "Maximum", "N Missing Obs")
BLUEs_all_summary[, 1:ncol(BLUEs_all_summary)] <- lapply(BLUEs_all_summary[, 1:ncol(BLUEs_all_summary)], function(x){gsub(".*:", "", x)})
BLUEs_all_summary[nrow(BLUEs_all_summary),] <- ifelse(is.na(BLUEs_all_summary[nrow(BLUEs_all_summary),]), 0, BLUEs_all_summary[nrow(BLUEs_all_summary),])
BLUEs_all_summary <- rownames_to_column(BLUEs_all_summary, var = "Summary Statistic")
write.csv(BLUEs_all_summary, 
          "blues_across_and_within_enviornment_summary.csv",
          row.names = FALSE)


# Merge the phenotype and genotype files
insertme <- full_join(BLUEs_all, geno, by = "GENOTYPE")
insertme <- insertme[order(insertme$dummy), ]  # Order by dummy
insertme <- insertme[1, ]
pheno_geno <- left_join(BLUEs_all, geno, by = "GENOTYPE")
pheno_geno <- rbind(insertme, pheno_geno)
pheno_geno <- pheno_geno[order(pheno_geno$dummy), ]  # Order by dummy
pheno_geno <- pheno_geno %>% filter(!is.na(dummy))  # Get rid of any genotype that is not present
pheno_geno[1, (1:30)] <- ""  # Replace any NAs with blank data
dropme <- c("13955-AGS-2026", "13955-JAMESTOWN", "13955-NCAG11", "13955-NC13-20076", "13955-GA06493-13LE6")
pheno_geno <- pheno_geno[!(pheno_geno$GENOTYPE %in% dropme), ]
pheno_geno <- pheno_geno %>%
  select(-dummy)
colnames(pheno_geno) <- gsub("FHB", "VR", colnames(pheno_geno))

# Write out rqtl input file
write.csv(pheno_geno,
          "rqtl_input_file.csv",
          row.names = FALSE)
```

# Make a pairs plot of traits

```{r}
# Create temp 
pairs_plot_dat<-BLUEs_mem

# Rename columns for the pairs plot
colnames(pairs_plot_dat) <- c("Genotype",
                              "FHB Visual Rating",
                              "Fusarium Damaged Kernels",
                              "Deoxynivalenol Content",
                              "Heading Date",
                              "Plant Height")

# Visualize first
pairs.panels(pairs_plot_dat[,2:ncol(pairs_plot_dat)],
             hist.col = "gray",
             lm = TRUE,
             stars = TRUE,
             digits = 2,
             density = FALSE,
             ellipses = FALSE)

# Set up JPEG file
jpeg(filename = "pairs_plot.jpg",
     width = 9,
     height = 9,
     units = "in",
     res = 320)

# Create pairs plot
pairs.panels(pairs_plot_dat[,2:ncol(pairs_plot_dat)],
             hist.col = "gray",
             lm = TRUE,
             stars = TRUE,
             digits = 2,
             density = FALSE,
             ellipses = FALSE)

# Save and close JPEG file
dev.off()
```

# Build Linkage Map

```{r}
# Read in file
cross_file <- read.cross("csv", 
                         file = "rqtl_input_file.csv",
                         genotypes = c("A", "B", "-"), 
                         alleles = c("A", "B"), 
                         crosstype = "dh")

# Remove markers with low P-value from a file
toss_me <- read.table("markers_to_remove.txt")[, 1]
gt <- geno.table(cross_file)
toss_me <- unique(c(toss_me, rownames(gt[gt$P.value < 0.0001, ])))
cross_file <- drop.markers(cross_file, toss_me)

# Remove unnecessary objects
remove(gt, toss_me)

# Chromosome names
chromosomes <- c(paste0("1", LETTERS[c(1,2,4)]),
                 paste0("2", LETTERS[c(1,2,4)]),
                 paste0("3", LETTERS[c(1,2,4)]),
                 paste0("4", LETTERS[c(1,2,4)]),
                 paste0("5", LETTERS[c(1,2,4)]),
                 paste0("6", LETTERS[c(1,2,4)]),
                 paste0("7", LETTERS[c(1,2,4)]))

# Create genetic map with cM instead of BP
cross_file <- mstmap(cross_file,
                     pop.type = "dh",
                     id = "GENOTYPE",
                     chr = chromosomes,
                     anchor = TRUE,
                     detectBadData = TRUE,
                     bychr = TRUE,
                     miss.thresh = 0.15,
                     mvest.bc = FALSE)

# Jitter map to improve marker distances
cross_file <- jittermap(cross_file)

# Subset and filter linkage groups
marker_count <- sapply(cross_file$geno, function(x) length(x$map))
marker_count <- data.frame(Chr = names(marker_count), n = marker_count) %>%
  filter(n > 6 & !Chr %in% c("1A.2", "6A.2"))
cross_file <- subset(cross_file, chr = marker_count$Chr)
cross_file <- jittermap(cross_file)

# Rename linkage groups
names(cross_file$geno) <- chromosomes

# Remove unnecessary objects
remove(marker_count)

# Check map metrics
nphe(cross_file)
nind(cross_file)
nchr(cross_file)
summary(cross_file)

# Plot linkage map
plotMap(cross_file, horizontal = FALSE, shift = FALSE, main = "NC13-20076 Double Haploid Linkage Map")

# Function to compare cM vs BP position
compare_bp_to_cm <- function(x){
  # Pull marker names
  mn <- markernames(x)
  
  # Pull positions of markers
  pos <- find.markerpos(x, mn)
  
  # Pull in rownames
  pos <- rownames_to_column(pos, var = "BP_Location")
  
  # Split the column BP_Location into a and b
  pos <- tidyr::separate(pos, BP_Location, into = c("a", "b"), sep = "_")
  
  # Rename columns
  colnames(pos) <- c("trash", "BP", "Chr", "cM")
  
  # Pull the three columns listed
  pos <- pos[, c("Chr", "BP", "cM")]
  
  # Bind marker names with their chromosme and positions
  pos <- cbind(mn, pos)
  
  # Rename columns
  colnames(pos) <- c("Markers", "Chr", "BP", "cM")
  
  # Make sure the BP and cM positions are numeric columns
  pos[, 3:4] <- lapply(pos[, 3:4], as.numeric)
  
  # Return the position dataframe 
  return(pos)
}

# Compare cM vs BP for each chromosome
pos <- compare_bp_to_cm(cross_file)

# Check and flip chromosome order if necessary
for (i in names(cross_file$geno)) {
  # Make an object that has only the curren chromosome
  q <- pos %>% filter(Chr == i)
  # If the first makrer pysical positon is greater than the last marker pysical position
  if (q[1, 3] > q[nrow(q), 3]) {
    # Print message
    print_message <- paste(paste("### Chromosome", i, "has been flipped ###"))
    print(paste(rep("#", nchar(print_message)), collapse = ""))
    print(print_message)
    print(paste(rep("#", nchar(print_message)), collapse = ""))
    
    # Then flip the linkage group
    cross_file <- flip.order(cross_file, i)
    
    # Remove the temporary dataframe 
    remove(q, print_message)
  } else {
    # Remove the temporary dataframe 
    remove(q)
  }
}

# Re-calculate positions after potential flipping
pos <- compare_bp_to_cm(cross_file)

# Plot cM vs BP again
ggplot(data = pos, aes(x = cM, y = BP / 1000000)) +
  geom_point() +
  facet_wrap(~Chr, ncol = 3, scales = "fixed") +
  coord_cartesian(ylim = c(0, 800), xlim = c(0, 250)) +
  labs(title = "Centimorgan Position vs. Megabase Pair",
       x = "Centimorgan (cM) Position",
       y = "Megabase Pair (Mbp) Position")

# Save the plot
ggsave(plot = last_plot(),
       filename = "cM_vs_bp_comparison.jpg",
       units = "in", width = 8, height = 12, dpi = 320)

# Remove temporary objects
remove(pos)

# Write final cross file
write.cross(cross_file,
            format = "csv",
            filestem = "rqtl_input_file_final")
```

# Find potential selfs 

```{r}
# # Find potential selfs
# potential_selfs <- pull.geno(cross_file)
# rownames(potential_selfs) <- cross_file$pheno$GENOTYPE
# potential_selfs <- t(potential_selfs)
# 
# # make a function to get counts
# count_values <- function(column) {
#   return(c(count_A = sum(column == 1, na.rm = TRUE),
#            count_B = sum(column == 2, na.rm = TRUE),
#            count_NA = sum(is.na(column))))
# }
# 
# # Make an object to bind on 
# check <- c()
# 
# # Bind in 
# for(i in 1:ncol(potential_selfs)){
#   
#   temp1<-data.frame(GENOTYPE=colnames(potential_selfs)[i],
#                     t(count_values(potential_selfs[,i])))
#   temp1$x2<-c(chisq.test(x = temp1[,2:3], p = rep(0.5, 2))$statistic)
#   temp1$p.value<-c(chisq.test(x = temp1[,2:3], p = rep(0.5, 2))$p.value)
#   check <-rbind(check, temp1)
#   remove(temp1)
#   
# }
# 
# # List of potential selfs
# potential_selfs <- check %>% filter(p.value<=1e-80)
# 
# # Write selfs
# write.csv(potential_selfs,
#           "list_of_potential_selfs.csv",
#           row.names = FALSE)
```

# QTL analysis without covariates - HD, PH, VR, FDK, DON

```{r}
# Calculate marker probabilities
cross_file<-calc.genoprob(cross_file, 
                          step=2.0, 
                          off.end=0.0, 
                          error.prob=1.0e-4, 
                          map.function="kosambi",
                          stepwidth="fixed")

# Calculate marker probabilities for a simulated genotype
cross_file<-sim.geno(cross_file, 
                     n.draws = 128, 
                     step = 2, 
                     off.end = 0.0, 
                     error.prob=1.0e-4, 
                     map.function="kosambi", 
                     stepwidth="fixed")

# Set the number of permutations
nperms=1000

# Pull traits
traits<-names(cross_file$pheno)[-1]

# Covariates - set to null if none are specified 
qtl_covariates <- NULL

# Make results vector
results<-list()

# Run initial interval mapping and pull out QTL
for (i in traits){
  
  # Announce 
  print(paste("------------ Interval Mapping of", i,"------------"))
  
  # Perform IM with multiple imputation method
  print("Interval mapping...")
  scans <- scanone(cross_file, 
                   pheno.col = i,
                   addcovar = qtl_covariates,
                   model = "normal", 
                   method = "hk") 
  print("Done")
  
  # Perform IM permutations mapping to define significance threshold
  print("Permutational interval mapping...")
  perms <- scanone(cross_file, 
                   pheno.col = i, 
                   addcovar = qtl_covariates,
                   model = "normal", 
                   method = "hk", 
                   n.perm = nperms, 
                   n.cluster = parallel::detectCores()-1) #set threshold
  print("Done")
  
  # Plot QTL Scan
  print("Plotting...")
  threshold <- summary(perms, alpha=0.05)
  plot(scans,main=paste("IM for", i)) 
  abline(h = threshold, lty = "dotted", lwd = 1, col="#cc0000")
  legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
  
  # Print plot
  jpeg(paste("Scan_IM_", i, ".jpg", sep = ""),
       width = 11,
       height = 4,
       units = "in",
       res = 320)
  threshold <- summary(perms, alpha=0.05)
  plot(scans, main = paste("IM for", i)) 
  abline(h = threshold, lty = "dotted", lwd = 1, col = "#cc0000")
  legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
  dev.off()
  print("Done")
  
  # Show the peak markers for QTL
  print("Defining QTL...")
  qtl <- summary(scans, 
                 perm = perms, 
                 lodcolum = 1, 
                 alpha=0.05)
  
  # Place outputs in lists
  results$IM$scan[[i]] <- scans # Place the scan a the list
  results$IM$perms[[i]] <- perms # Place the permutations a the list
  results$IM$threshold[[i]] <- threshold # Place the thresholds a the list
  
  # If not QTL is found
  if(nrow(qtl)==0){
    # Print out
    print("No QTL identified in initial scan... Moving onto next trait!")
    next
  }
  
  # Rename QTL to identify which scan they came from
  qtl$name <- paste("IM_", qtl$chr, "-pos-", qtl$pos, sep = "")
  print("Done")
  
  # Define the QTL locations and effects
  print("Drawing QTL...")
  colnames(scans) <- c("chr", "pos", "lod")
  
  # Set up objects for defining QTL
  c <- qtl[,1] # Define the chromosomes where QTL are found
  p <- qtl[,2] # Define the positions of the QTL
  a <- subset(cross_file, chr=c) # Subset the chromosomes where QTL are found
  
  # Make new cross with genome subset
  a <- sim.geno(a, 
                n.draws = 128, 
                step = 2, 
                off.end = 0.0, 
                error.prob = 1.0e-4, 
                map.function = "kosambi", 
                stepwidth = "fixed")
  
  # Make a QTL object from that subset
  madeqtl <- makeqtl(a, 
                     c, 
                     p, 
                     qtl.name = qtl[,4], 
                     what = c("prob")) 

  # Place that QTL object in a list
  results$IM$qtl[[i]] <- madeqtl 
  print("Done")
  
  # Announce
  print("Running drop-one QTL analysis to check significance...")
  
  # Test the significance of those QTL using drop one analysis
  qtlfit <- fitqtl(cross_file, 
                   qtl = results$IM$qtl[[i]], 
                   pheno.col = i,
                   model = "normal", 
                   method = "hk") 
  
  # Remove insignificant QTL
  if(!is.null(qtlfit$result.drop)){
    # Make an object of the drop results of the fit QTL object
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the insignificant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Make a dataframe with insignificant QTL
    a <- data.frame(name = rownames(a[a$sig==0,]))
    
    # Drop those QTL
    madeqtl <- dropfromqtl(madeqtl,
                           qtl.name = a$name)
    
    # Put that in object
    results$IM$qtl[[i]] <- madeqtl 
    
    # Remove temporary 
    remove(a,c,p,scans,perms,threshold)
  }else{
    # Remove temporary dataframes
    remove(a,c,p,scans,perms,threshold)
  }
  
  # Set vectors outside the loop
  j=1
  
  # Make initial check object
  qtl_check<-results$IM$qtl[[i]]
  
  # Run MQM until no significant peaks
  repeat{
    
    # Announce  
    print(paste("-------- Performing Additional QTL Scan for Trait", i,"--------"))
    
    # Run multiple QTL mapping
    mqm <- addqtl(cross = cross_file, 
                  pheno.col = i, 
                  qtl = qtl_check, 
                  covar = qtl_covariates, 
                  method = "hk")
    
    # Put that in the list
    results[[paste("MQM", j, sep="")]]$scan[[i]] <- mqm
    
    # Plot QTL Scan
    print("Plotting...")
    plot(mqm, main = paste("MQM", j, "for", i)) 
    abline(h = results$IM$threshold[[i]], lty = "dotted", lwd = 1, col = "#cc0000")
    legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
    print("Done")
    
    # Write out picture to directory
    jpeg(paste("Scan_",paste("MQM", j, sep=""),"_", i, ".jpg", sep = ""),
     width = 11,
     height = 4,
     units = "in",
     res = 320)
    plot(mqm, main = paste("MQM", j, "for", i)) 
    abline(h = results$IM$threshold[[i]], lty = "dotted", lwd = 1, col = "#cc0000")
    legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
    dev.off()

    #make a qtl object
    qtl <- summary(mqm, 
                   perm = results$IM$perms[[i]], 
                   lodcolum = 1, 
                   alpha = 0.05)
  
    if(nrow(qtl)==0){
      # Make a null object in the list of list
      results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- NULL
      
      # Announce
      print(paste("There were no new QTL identified for", i, "aborting loop"))
      
      # Break the loop
      break
    }else{
      # Rename QTL to identify which scan they came from
      qtl$name=paste(paste("MQM", j, "_", sep=""), qtl$chr,"-pos-",qtl$pos,sep="")
       
      # Defining QTL
      print("Drawing new QTL")
      c<-qtl[,1] # Define the chromosomes where QTL are found
      p<-qtl[,2] # Define the positions of the QTL
      a<-subset(cross_file, chr=c) # Subset the chromosomes where QTL are found
       
      # Simulate the genome for that subset
      a <- sim.geno(a, 
                    n.draws = 128, 
                    step = 2, 
                    off.end = 0.0, 
                    error.prob = 1.0e-4, 
                    map.function = "kosambi", 
                    stepwidth = "fixed") 
       
      # Make a QTL object from that subset
      madeqtl <- makeqtl(a, 
                         c, 
                         p, 
                         qtl.name = qtl[,4], 
                         what = c("prob")) 
   
      # Place that QTL object in a list
      results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- madeqtl 
      print("Done")
      
      # Announce
      print("Running drop-one QTL analysis...")
       
      # Test the significance of those QTL using dropone analysis
      qtlfit <- fitqtl(cross_file, 
                       qtl = madeqtl, 
                       pheno.col = i, 
                       get.ests = T,
                       model = "normal", 
                       method = "hk") 
      
      # Check results
      if(!is.null(qtlfit$result.drop)){
        # Announce
        print("Checking drop-one analysis for significance")
        
        # Make a dataframe of the drop results
        a <- as.data.frame(qtlfit$result.drop)
        
        # Check significance 
        a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
        
        # Check significance 
        a <- data.frame(name=rownames(a[a$sig==0,]))
        
        # Separate the column name into sections 
        a <- tidyr::separate(data = a, 
                             col = "name",
                             into = c("chr", "trash", "pos"),
                             sep = "-")
        
        # Make sure position is a number
        a$pos <- as.numeric(a$pos)
        
        # Make the chromosome object from the trait
        a$chr <- gsub(paste("MQM", j, "_", sep = ""),"",a$chr)
        
        # Drop the insignificant QTL from the object
        madeqtl <- dropfromqtl(madeqtl,
                               chr = a$chr,
                               pos = a$pos)
        
        # Add the significant QTL to the object
        madeqtl <- addtoqtl(cross_file,
                            qtl = madeqtl,
                            chr = qtl_check$chr,
                            pos = qtl_check$pos,
                            qtl.name = qtl_check$name)
              
        
        # Add this QTL object to the list of list
        results[[paste("MQM", j, sep="")]]$qtl[[i]] <- madeqtl 
        
        # Remove temporary dataframes
        remove(a, c, p)
        }else{
          # Announce 
          print(paste("There was only one new QTL identified for ",
                      i,
                      " in ", 
                      paste("MQM", j, sep = ""),
                      "... Checking significance!",
                      sep = ""))
          
          # If this QTL is significant
          if(qtlfit$result.full[1,6]<0.05){
            # Announce
            print("New QTL is significant, placing in total model!")
            
            # Add that significant peak to the QTL object
            madeqtl <- addtoqtl(cross_file,
                                qtl = madeqtl,
                                chr = qtl_check$chr,
                                pos = qtl_check$pos,
                                qtl.name = qtl_check$name)
            
            # Add the object to the list of list
            results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- madeqtl 
            }else{
              # Make the multiple QTL model NULL
              results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- NULL 
              
              # Announce
              print(paste("There were no new QTL identified for", i, "concluding loop."))
              
              # Break loop 
              break
            }
          }
        }
      
    
    # Add result to object to check
    qtl_check <- results[[paste("MQM", j, sep="")]]$qtl[[i]]
    
    # Add 1 to the j vector to indicate what round we are on
    j=j+1
  }
  
  # Check
  if(j-1==0){
    # Pull and make final qtl object
    finalqtl <- results$IM$qtl[[i]]
  }else{
    # Pull and make final qtl object
    finalqtl <- results[[paste("MQM", j-1, sep="")]]$qtl[[i]]
      
  }
  
  # Check for significance
  qtlfit <- fitqtl(cross_file, 
                   qtl = finalqtl, 
                   pheno.col = i, 
                   get.ests = T,
                   model = "normal", 
                   method = "hk") 
  
  # Rename the QTL
  a <- finalqtl
  a <- data.frame(summary(a))
  a <- tidyr::separate(a, col = "name", into=c("model", "trash"), sep = "_")
  a$name <- paste(a$model, "_", a$chr, "-pos-", a$pos, sep = "")
  finalqtl$name = a$name
  remove(a)
  
  # Announce
  print("Filtering insignificant markers...")
  
  # If there are drop one analysis results
  if(!is.null(qtlfit$result.drop)){
    # Pull results into a dataframe
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the significant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Select the insignificant markers 
    a <- data.frame(name=rownames(a[a$sig==0,]))
    
    # Remove those QTL from the final QTL object
    finalqtl <- dropfromqtl(finalqtl,
                            qtl.name = a$name)
    
    # Add this to the list of list
    results$final$qtl_unrefine[[i]] <- finalqtl 
    
    # Remove the object
    remove(a, finalqtl)
  }else{
    # Put the final object in the list of list
    results$final$qtl_unrefine[[i]] <- finalqtl
    
    # Remove the object finalqtl
    remove(finalqtl)
  }
   
  # Announce
  print("Refining QTL position...")
  
  # Refine the QTL with the refine 
  results$final$qtl_refine[[i]] <- refineqtl(cross = cross_file, 
                                             pheno.col = i, 
                                             qtl = results$final$qtl_unrefine[[i]], 
                                             verbose = FALSE,
                                             method = "hk")
  # Rename the QTL
  a <- results$final$qtl_refine[[i]]
  a <- data.frame(summary(a))
  a <- tidyr::separate(a, col = "name", into=c("model", "trash"), sep = "_")
  a$name <- paste(a$model, "_", a$chr, "-pos-", a$pos, sep = "")
  results$final$qtl_refine[[i]]$name <- a$name
  remove(a)
  
  # Final significance check
  qtlfit <- fitqtl(cross_file, 
                   qtl = results$final$qtl_refine[[i]], 
                   pheno.col = i, 
                   get.ests = T,
                   model = "normal", 
                   method = "hk") 
  
  # Put the final QTL object into finalqtl
  finalqtl <- results$final$qtl_refine[[i]]
  
  # If there are drop one analysis results
  if(!is.null(qtlfit$result.drop)){
    # Pull results into a dataframe
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the significant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Select the insignificant markers 
    a <- data.frame(name=rownames(a[a$sig==0,]))
    
    # Remove those QTL from the final QTL object
    finalqtl <- dropfromqtl(finalqtl,
                            qtl.name = a$name)
    
    # Add this to the list of list
    results$final$qtl_refine_filt[[i]] <- finalqtl 
    
    # Remove the object
    remove(a, finalqtl)
  }else{
    # Put the final object in the list of list
    results$final$qtl_refine_filt[[i]] <- finalqtl
    
    # Remove the object finalqtl
    remove(finalqtl)
  }
   
  # Create an object for support LOD internvals 
  droplodint<-c()
  
  #create QTL 1.5 drop LOD intervals
  for(z in results$final$qtl_refine_filt[[i]]$name){
    # Pull data for specific QTL
    a <- data.frame(name = z)
    
    # Pull the scan name 
    a <- tidyr::separate(data = a,
                         col = "name",
                         into = c("scan", "other"),
                         sep = "_",
                         remove = FALSE)
    
    # Pull the position name
    a <- tidyr::separate(data = a,
                         col = "other",
                         into = c("chr", "trash", "pos"),
                         sep = "-",
                         remove = TRUE)
    
    # Pull the relevant scan 
    b <- results[[a$scan]]$scan[[i]]
    
    # Find the nearest sudo marker to the LOD peak
    c <- find.pseudomarker(cross = cross_file,
                           chr = a$chr,
                           pos = as.numeric(a$pos))
    
    # Pull the confidence interval for 1.5 LOD drop
    d <- lodint(results = b,
                chr = a$chr,
                qtl.index = c,
                drop = 1.5,
                lodcolumn = 1,
                expandtomarkers = TRUE)
    
    # Create a dataframe with that data
    d <- data.frame(name = z, 
                    trait = i,
                    chr = unique(d$chr),
                    start_marker = rownames(d)[1],
                    start = d[1,2], 
                    mid_marker = rownames(d)[2],
                    mid_pos = d[2,2],
                    stop_marker = rownames(d)[3],
                    stop = d[3,2])
    
    # Bind into lodint object
    droplodint <- rbind(droplodint, d)
    
    # Remove temporary data
    remove(a,b,c,d)
  }
  
  # Place in results
  results$final$qtl_support_intervals[[i]] <- droplodint
  
  # Remove
  remove(droplodint)
  
}

# Rename results
results_HD_PH_VR_FDK_DON<-results

# Remove results
remove(results)
```

# Pull HD and PH Marker Covariates

```{r}
# Pull QTL Support Intervals
covars <- rbind(results_HD_PH_VR_FDK_DON$final$qtl_support_intervals$HD_ME,
                results_HD_PH_VR_FDK_DON$final$qtl_support_intervals$PH_ME)

# Make a dataframe 
covar_markers <- data.frame(GENOTYPE = cross_file$pheno$GENOTYPE)

# For each QTL support intervals
for(i in 1:nrow(covars)){
  # Take this row
  a <- covars[i,]
  
  # Then fill in the genome
  b <- fill.geno(cross = cross_file,
                 method = c("no_dbl_XO"),
                 map.function = "kosambi")
  
  # Pull the cross for the specific genome
  b <- pull.geno(cross = b,
                 chr = a$chr)
  
  # Pull the marker name
  a <- find.marker(cross = cross_file,
                   chr = a$chr,
                   pos = a$mid_pos)
  
  # Pull the data frame
  b <- as.data.frame(b[,a])
  
  # Rename the column
  colnames(b) <- a
  
  # Bind it into the dataframe
  covar_markers <- cbind(covar_markers, b)
  
  # Remove the temporary data
  remove(a, b)
}
```

# Visualize HD and PH QTL

```{r}
# Write function to visualize
qtl_visualization<- function(results_data, 
                             color_palette,
                             traits,
                             y_axis,
                             covariates = covar_markers,
                             label_size = 10){
  # Make object for ggplot formatted data
  dat_ggplot <- c()
  
  # For each trait
  for(i in traits){
    # Pull a temporary dataframe 
    a <- results_data$final$qtl_support_intervals[[i]]
    # Rbind on results
    dat_ggplot <- rbind(dat_ggplot, a)
    # Remove 
    remove(a)
  }
  
  # Get a dataframe of the markers across the genome for this image
  d <- results_data$IM$scan$VR_ME %>%
    filter(chr %in% dat_ggplot$chr)
  
  # Mutate chromosome so that it is both chromosome and trait
  dat_ggplot <- dat_ggplot %>% 
    mutate(chr = paste(chr, trait, sep = "_"))
  
  # Create a list for images
  finalplot <- list()
  
  # For i in unique chromosomes 
  for(i in unique(d$chr)){
    # Pull a temporary dataframe
    a <- dat_ggplot[grep(i, dat_ggplot$chr),]
    
    # Redefine trait with color pallet levels
    a$trait <- factor(a$trait, levels = names(color_palette))
    
    # Make QTL name unique
    a$name <- seq(1:nrow(a))
    
    # Only pull the chromosome listed in object d from above
    b <- d[d$chr==i,]
    
    # Remove all sudo-markers from b
    b <- b[-grep("loc", rownames(b)),]
    
    # Move the rownames into a column called markers 
    b <- rownames_to_column(b, var = "marker")
    
    # Make b$chr a character
    b$chr <- as.character(b$chr)
    
    # Make an object called label that is made from the covariates on that chromsomes
    Label<-colnames(covar_markers)[grep(i, colnames(covar_markers))]
    
    # make linear a
    linear_a <- c()
    
    # Make a marker version and concatinate 
    for(j in 1:nrow(a)){
      # Pull marker matrix 
      temp1 <- b[b$pos>=a$start[j] & b$pos<=a$stop[j],]
      
      # Make new dataframe
      temp1$chr <- a[j,"trait"]
      
      # Make new column 
      temp1$qtl <- a[j, "name"]
      
      # rbind
      linear_a <- rbind(linear_a, temp1)
      
      # Remove
      remove(temp1)
    }
    
    # Give b a new column 
    b$qtl <- "Linkage Map"
    
    # Bind
    b <- rbind(b,linear_a)
    
    # Replace chromosome name
    b$chr <- ifelse(b$chr == i, "Linkage Map", b$chr)
    
    # Redefine factor for chr
    b$chr <- factor(b$chr, levels = c("Linkage Map", names(color_palette)))
  
    # Make temp color_pallet 
    temp_color_pallet <- c(c("black"), color_palette)
    
    # Make color for linkage map
    names(temp_color_pallet)[1] <- "Linkage Map"
    
    # define qtl
    b$qtl <- factor(b$qtl, levels = c("Linkage Map", a$name))
    
    if(i %in% y_axis){

      # Create first plot
      c <- ggplot(data = b, aes(x = qtl, y = pos, color = chr))+ # Make plot out of object b
        geom_point(size = 2, show.legend = TRUE, position = position_dodge(0.2))+ # Make points that represent the markers
        geom_line(linewidth = 1, show.legend = TRUE, position = position_dodge(0.2))+ # Make a line that represents the length of the linkage group 
        annotate("text", x = "Linkage Map", y = -12.5, label = i, color = "black", size = label_size)+ # Add linkage group name
        scale_y_reverse(limits = c(250,-25), breaks = seq(250, 0, by = -25))+ # Scale the y axis 
        scale_color_manual(values = temp_color_pallet, # Set the values of the color palette
                           drop = FALSE)+ # and make it so that no levels are dropped
        theme_classic()+ # Add the classic theme 
        theme(axis.title.x = element_blank(), # Get rid of the x-axis title
              axis.text.x = element_blank(), # Get rid of the x-axis text
              axis.ticks.x = element_blank(), # Get rid of the x-axis ticks
              axis.line.x = element_blank())+ # Get rid of the x-axis line
        labs(color = "Color Legend", # Name the legend 
             y = "cM") # Lable the y-axis as "cM"  
            
    }else{
      # Create first plot
      c <- ggplot(data = b, aes(x = qtl, y = pos, color = chr))+ # Make plot out of object b
        geom_point(size = 2, show.legend = TRUE, position = position_dodge(0.2))+ # Make points that represent the markers
        geom_line(linewidth = 1, show.legend = TRUE, position = position_dodge(0.2))+ # Make a line that represents the length of the linkage group 
        annotate("text", x = "Linkage Map", y = -12.5, label = i, color = "black", size = label_size)+ # Add linkage group name
        scale_y_reverse(limits = c(250,-25), breaks = seq(250, 0, by = -10))+ # Scale the y axis 
        scale_color_manual(values = temp_color_pallet, # Set the values of the color palette
                           drop = FALSE)+ # and make it so that no levels are dropped
        theme_classic()+ # Add the classic theme 
        theme(axis.title.x = element_blank(), # Get rid of the x-axis title
              axis.text.x = element_blank(), # Get rid of the x-axis text
              axis.ticks.x = element_blank(), # Get rid of the x-axis ticks
              axis.line.x = element_blank(), # Get rid of the y-axis line
              axis.title.y = element_blank(), # Get rid of the y-axis title
              axis.text.y = element_blank(), # Get rid of the y-axis text
              axis.ticks.y = element_blank(), # Get rid of the y-axis ticks
              axis.line.y = element_blank(),)+ # Get rid of the y-axis line
        labs(color = "Color Legend", # Name the legend 
             y = "cM") # Lable the y-axis as "cM"  
    }
    
    
    
    # If label exists   
    if(length(Label)>0){
      # Add a green point for HD and PH covariates 
      c <- c+
        geom_point(data = d[rownames(d) %in% Label,], 
                   aes(x = "Linkage Map", y = pos), 
                   color = "#ff6700", 
                   size = 4, 
                   shape = 17) +
        geom_hline(data = d[rownames(d) %in% Label,], 
                   aes(yintercept = pos), 
                   color = "#ff6700", 
                   lty = 2,
                   linewidth = 1)
    }
      
    # Add to the object finalplot and name it 
    finalplot[[paste("chr",i,sep="_")]] <- c
    
    # Remove temporary dataframes 
    remove(a,b,c)
  }
  
  # return object
  return(finalplot)
}

# Pull vector of traits
traits <- names(cross_file$pheno)[c(grep("HD", names(cross_file$pheno)),
                                    grep("PH", names(cross_file$pheno)))]

# Make a color pallet
color_palette <- c(
  "HD_ME" = "#0000FF",        # Blue
  "HD_RAL19" = "#2F4F4F",     # DarkSlateGray
  "HD_RAL20" = "#00FFFF",     # Cyan
  "HD_KIN20" = "#1E90FF",     # DodgerBlue
  "HD_WAR20" = "#5F9EA0",     # CadetBlue
  "PH_ME" = "#EE82EE",        # Violet
  "PH_RAL20" = "#BA55D3",     # MediumOrchid
  "PH_KIN20" = "#9932CC"      # DarkOrchid
)

# Run function
finalplot <- qtl_visualization(results_data = results_HD_PH_VR_FDK_DON,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = c("4A"),
                               label_size = 5)

# Create final plot
a <- (finalplot$chr_4A+
        finalplot$chr_5A+
        finalplot$chr_6A+
        finalplot$chr_6D+
        finalplot$chr_7A+
        finalplot$chr_7B)+
    plot_layout(guides = "collect", 
                nrow = 1)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Plant Height (PH) and Heading Date (HD)")

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_hd_and_ph.jpg",
       width = 14,
       height = 8,
       dpi = 320,
       units = "in")
```

# Visualize HD and PH QTL for ME only

```{r}
# Pull vector of traits
traits <- c("HD_ME", "PH_ME")

# Make a color pallet
color_palette <- c(
  "Heading Date" = "#0000FF",        # Blue
  "Plant Height" = "#EE82EE"         # Violet
)

# Make temp
temp1 <- results_HD_PH_VR_FDK_DON

# Rename
temp1$final$qtl_support_intervals$HD_ME$trait <- "Heading Date"
temp1$final$qtl_support_intervals$PH_ME$trait <- "Plant Height"

# Run function
finalplot <- qtl_visualization(results_data = temp1,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = "4A",
                               label_size = 5)

# Remove temp
remove(temp1)

# Create final plot
a <- (finalplot$chr_4A+
        finalplot$chr_5A+
        finalplot$chr_6A+
        finalplot$chr_6D+
        finalplot$chr_7B)+
    plot_layout(guides = "collect", 
                nrow = 1)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Plant Height (PH) and Heading Date (HD)")

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_hd_and_ph_ME_only.jpg",
       width = 14,
       height = 8,
       dpi = 320,
       units = "in")
```

# Visualize HD, PH, VR, FDK, and DON

```{r}
# Pull vector of traits
traits <- names(cross_file$pheno)[-1]

# Make a color pallet
color_palette <- c(
  "HD_ME" = "#0000FF",        # Blue
  "HD_RAL19" = "#2F4F4F",     # DarkSlateGray
  "HD_RAL20" = "#00FFFF",     # Cyan
  "HD_KIN20" = "#1E90FF",     # DodgerBlue
  "HD_WAR20" = "#5F9EA0",     # CadetBlue
  "PH_ME" = "#EE82EE",        # Violet
  "PH_RAL20" = "#BA55D3",     # MediumOrchid
  "PH_KIN20" = "#9932CC",     # DarkOrchid
  "VR_ME" = "#FF0000",        # Red
  "VR_KIN19" = "#8B0000",     # DarkRed
  "VR_KIN20" = "#B22280",     # Firebrick
  "VR_RAL19" = "#A0522D",     # Brown
  "VR_RAL20" = "#FF4500",     # OrangeRed
  "VR_WAR20" = "#FF6347",     # Tomato
  "FDK_ME" = "#E6CC00",       # Yellow
  "FDK_KIN19" = "#B8860B",    # DarkGoldenrod
  "FDK_KIN20" = "#FFD700",    # Gold
  "FDK_RAL19" = "#DAA520",    # Goldenrod
  "FDK_RAL20" = "#F0E68C",    # Khaki
  "FDK_WAR19" = "#EEE8AA",    # PaleGoldenrod
  "FDK_WAR20" = "#8B864E",    # Khaki4
  "DON_ME" = "#00FF00",       # DarkGreen
  "DON_KIN19" = "#66CD00",    # Chartreuse3
  "DON_KIN20" = "#556B2F",    # DarkOliveGreen
  "DON_RAL19" = "#8FBC8F",    # DarkSeaGreen
  "DON_RAL20" = "#6B8E23",    # OliveDrab
  "DON_WAR19" = "#98FB98",    # PaleGreen
  "DON_WAR20" = "#00FF7F"     # SpringGreen1
)

# Run function
finalplot <- qtl_visualization(results_data = results_HD_PH_VR_FDK_DON,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = c("1A", "3B", "6A", "7D"),
                               label_size = 5)

# Create final plot
a <- (finalplot$chr_1A+
        finalplot$chr_2A+
        finalplot$chr_2B+
        finalplot$chr_3A+
        finalplot$chr_3B+
        finalplot$chr_4A+
        finalplot$chr_5A+
        finalplot$chr_5B+
        finalplot$chr_6A+
        finalplot$chr_6D+
        finalplot$chr_7A+
        finalplot$chr_7B+
        finalplot$chr_7D)+
    plot_layout(guides = "collect", nrow = 4)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Plant Height (PH), Heading Date (HD), Visual Rating (VR), Fusarium Damaged Kernels (FDK), and Deoxynivalenol Content (DON)") &
  theme(legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        title = element_text(size = 20),
        text = element_text(size = 20))

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_hd_ph_vr_fdk_don_unadjusted.jpg",
       width = 22,
       height = 15,
       dpi = 320,
       units = "in")
```

# Visualize HD, PH, VR, FDK, and DON for ME only

```{r}
# Pull vector of traits
traits <- c("HD_ME", "PH_ME", "VR_ME", "FDK_ME", "DON_ME")

# Make a color pallet
color_palette <- c(
  "Heading Date" = "#0000FF",                # Blue
  "Plant Height" = "#EE82EE",                # Violet
  "Visual Rating" = "#FF0000",               # Red  
  "Fusarium Damaged Kernels" = "#E6CC00",    # Yellow
  "Deoxynivalenol Content" = "#00FF00"       # Green
)


# Make temp
temp1 <- results_HD_PH_VR_FDK_DON

# Rename
temp1$final$qtl_support_intervals$HD_ME$trait <- "Heading Date"
temp1$final$qtl_support_intervals$PH_ME$trait <- "Plant Height"
temp1$final$qtl_support_intervals$VR_ME$trait <- "Visual Rating"
temp1$final$qtl_support_intervals$FDK_ME$trait <- "Fusarium Damaged Kernels"
temp1$final$qtl_support_intervals$DON_ME$trait <- "Deoxynivalenol Content"



# Run function
finalplot <- qtl_visualization(results_data = temp1,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = c("1A", "3B", "6A", "7D"),
                               label_size = 5)

# Remove temp
remove(temp1)

# Create final plot
a <- (finalplot$chr_1A+
        finalplot$chr_2A+
        finalplot$chr_2B+
        finalplot$chr_3A+
        finalplot$chr_3B+
        finalplot$chr_4A+
        finalplot$chr_5A+
        finalplot$chr_5B+
        finalplot$chr_6A+
        finalplot$chr_6D+
        finalplot$chr_7A+
        finalplot$chr_7B+
        finalplot$chr_7D)+
    plot_layout(guides = "collect", nrow = 4)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Plant Height (PH), Heading Date (HD), Visual Rating (VR), Fusarium Damaged Kernels (FDK), and Deoxynivalenol Content (DON)")

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_hd_ph_vr_fdk_don_unadjusted_ME_only.jpg",
       width = 20,
       height = 15,
       dpi = 320,
       units = "in")
```

# Percent variance calculations - HD, PH, VR, FDK, and DON without adjustment

```{r}
# Pull all traits
traits <- names(cross_file$pheno)[-1]

# Make an object for support internvals
final_qtls <- c()

# For i in trait names
for(i in traits){
  # Pull temporary dataframe
  a <- results_HD_PH_VR_FDK_DON$final$qtl_support_intervals[[i]]
  
  # Format final QTL object
  final_qtls <- rbind(final_qtls, a)
  
  # Remove final object
  remove(a)
}

# Make an object for information
qtl_info_drop_one <- c()
qtl_info_full <- c()

# For i in final_qtls object
for(i in traits){
  # Pull data
  a <- results_HD_PH_VR_FDK_DON$final$qtl_refine_filt[[i]]
  
  # If a is NULL
  if(is.null(a)){
    # Move to next trait
    next
  }
  
  # Fit QTL
  b <- fitqtl(cross_file, 
              qtl =results_HD_PH_VR_FDK_DON$final$qtl_refine_filt[[i]], 
              pheno.col = i, 
              get.ests = T,
              model = "normal", 
              method = "hk") 
  
  # Get full model
  c <- as.data.frame(b$result.full)
  
  # Move effect into column name
  c$effect <- rownames(c)
  rownames(c) <- NULL
  
  # Get drop one 
  d <- as.data.frame(b$result.drop)
  
  # Move QTL name into column
  d$name <- rownames(d)
  rownames(d) <- NULL
  
  # Get effect estimates
  d <- left_join(d,
                 data.frame(name = names(b$ests$ests), 
                            est_effect = b$ests$ests),
                 by = "name") 

  
  # Bind in data
  e <- results_HD_PH_VR_FDK_DON$final$qtl_support_intervals[[i]]
  
  # Left join
  d <- left_join(d, e, by = "name")
  
  # Add trait names to both full model
  c$trait <- i
  
  # Bind in data
  qtl_info_drop_one <- rbind(qtl_info_drop_one, d)
  qtl_info_full <- rbind(qtl_info_full, c)
  
  # Remove
  remove(a,b,c,d,e)
}



# Write file
write.csv(qtl_info_drop_one,
          "hd_ph_vr_fdk_don_drop_one_qtl_info_no_adjustment.csv",
          row.names = FALSE)

# Write file
write.csv(qtl_info_full,
          "hd_ph_vr_fdk_don_full_model_qtl_info_no_adjustment.csv",
          row.names = FALSE)
```

# QTL analysis with HD and PH covariates - VR, FDK, DON

```{r}
# Set the number of permutations
nperms=1000

# Pull traits
traits<-names(cross_file$pheno)[c(grep("VR", names(cross_file$pheno)),
                                  grep("FDK", names(cross_file$pheno)),
                                  grep("DON", names(cross_file$pheno)))]

# Covariates - set to null if none are specified 
qtl_covariates <- covar_markers[,2:ncol(covar_markers)]

# Make results vector
results<-list()

# Run initial interval mapping and pull out QTL
for (i in traits){
  
  # Announce 
  print(paste("------------ Interval Mapping of", i,"------------"))
  
  # Perform IM with multiple imputation method
  print("Interval mapping...")
  scans <- scanone(cross_file, 
                   pheno.col = i,
                   addcovar = qtl_covariates,
                   model = "normal", 
                   method = "hk") 
  print("Done")
  
  # Perform IM permutations mapping to define significance threshold
  print("Permutational interval mapping...")
  perms <- scanone(cross_file, 
                   pheno.col = i, 
                   addcovar = qtl_covariates,
                   model = "normal", 
                   method = "hk", 
                   n.perm = nperms, 
                   n.cluster = parallel::detectCores()-1) #set threshold
  print("Done")
  
  # Plot QTL Scan
  print("Plotting...")
  threshold <- summary(perms, alpha=0.05)
  plot(scans,main=paste("IM for", i)) 
  abline(h = threshold, lty = "dotted", lwd = 1, col="#cc0000")
  legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
  
  # Print plot
  jpeg(paste("Scan_IM_", i, "_With_Adjustment.jpg", sep = ""),
       width = 11,
       height = 4,
       units = "in",
       res = 320)
  threshold <- summary(perms, alpha=0.05)
  plot(scans, main = paste("IM for", i)) 
  abline(h = threshold, lty = "dotted", lwd = 1, col = "#cc0000")
  legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
  dev.off()
  print("Done")
  
  # Show the peak markers for QTL
  print("Defining QTL...")
  qtl <- summary(scans, 
                 perm = perms, 
                 lodcolum = 1, 
                 alpha=0.05)
  
  # Place outputs in lists
  results$IM$scan[[i]] <- scans # Place the scan a the list
  results$IM$perms[[i]] <- perms # Place the permutations a the list
  results$IM$threshold[[i]] <- threshold # Place the thresholds a the list
  
  # If not QTL is found
  if(nrow(qtl)==0){
    # Print out
    print("No QTL identified in initial scan... Moving onto next trait!")
    next
  }
  
  # Rename QTL to identify which scan they came from
  qtl$name <- paste("IM_", qtl$chr, "-pos-", qtl$pos, sep = "")
  print("Done")
  
  # Define the QTL locations and effects
  print("Drawing QTL...")
  colnames(scans) <- c("chr", "pos", "lod")
  
  # Set up objects for defining QTL
  c <- qtl[,1] # Define the chromosomes where QTL are found
  p <- qtl[,2] # Define the positions of the QTL
  a <- subset(cross_file, chr=c) # Subset the chromosomes where QTL are found
  
  # Make new cross with genome subset
  a <- sim.geno(a, 
                n.draws = 128, 
                step = 2, 
                off.end = 0.0, 
                error.prob = 1.0e-4, 
                map.function = "kosambi", 
                stepwidth = "fixed")
  
  # Make a QTL object from that subset
  madeqtl <- makeqtl(a, 
                     c, 
                     p, 
                     qtl.name = qtl[,4], 
                     what = c("prob")) 

  # Place that QTL object in a list
  results$IM$qtl[[i]] <- madeqtl 
  print("Done")
  
  # Announce
  print("Running drop-one QTL analysis to check significance...")
  
  # Test the significance of those QTL using drop one analysis
  qtlfit <- fitqtl(cross_file, 
                   qtl = results$IM$qtl[[i]], 
                   pheno.col = i,
                   model = "normal", 
                   method = "hk") 
  
  # Remove insignificant QTL
  if(!is.null(qtlfit$result.drop)){
    # Make an object of the drop results of the fit QTL object
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the insignificant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Make a dataframe with insignificant QTL
    a <- data.frame(name = rownames(a[a$sig==0,]))
    
    # Drop those QTL
    madeqtl <- dropfromqtl(madeqtl,
                           qtl.name = a$name)
    
    # Put that in object
    results$IM$qtl[[i]] <- madeqtl 
    
    # Remove temporary 
    remove(a,c,p,scans,perms,threshold)
  }else{
    # Remove temporary dataframes
    remove(a,c,p,scans,perms,threshold)
  }
  
  # Set vectors outside the loop
  j=1
  
  # Make initial check object
  qtl_check<-results$IM$qtl[[i]]
  
  # Run MQM until no significant peaks
  repeat{
    
    # Announce  
    print(paste("-------- Performing Additional QTL Scan for Trait", i,"--------"))
    
    # Run multiple QTL mapping
    mqm <- addqtl(cross = cross_file, 
                  pheno.col = i, 
                  qtl = qtl_check, 
                  covar = qtl_covariates, 
                  method = "hk")
    
    # Put that in the list
    results[[paste("MQM", j, sep="")]]$scan[[i]] <- mqm
    
    # Plot QTL Scan
    print("Plotting...")
    plot(mqm, main = paste("MQM", j, "for", i)) 
    abline(h = results$IM$threshold[[i]], lty = "dotted", lwd = 1, col = "#cc0000")
    legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
    print("Done")
    
    # Write out picture to directory
    jpeg(paste("Scan_",paste("MQM", j, sep=""),"_", i, "_With_Adjustment.jpg", sep = ""),
     width = 11,
     height = 4,
     units = "in",
     res = 320)
    plot(mqm, main = paste("MQM", j, "for", i)) 
    abline(h = results$IM$threshold[[i]], lty = "dotted", lwd = 1, col = "#cc0000")
    legend("topleft",legend = c("p=0.05"),col = c("#cc0000"),lty = "dotted")
    dev.off()

    #make a qtl object
    qtl <- summary(mqm, 
                   perm = results$IM$perms[[i]], 
                   lodcolum = 1, 
                   alpha = 0.05)
  
    if(nrow(qtl)==0){
      # Make a null object in the list of list
      results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- NULL
      
      # Announce
      print(paste("There were no new QTL identified for", i, "aborting loop"))
      
      # Break the loop
      break
    }else{
      # Rename QTL to identify which scan they came from
      qtl$name=paste(paste("MQM", j, "_", sep=""), qtl$chr,"-pos-",qtl$pos,sep="")
       
      # Defining QTL
      print("Drawing new QTL")
      c<-qtl[,1] # Define the chromosomes where QTL are found
      p<-qtl[,2] # Define the positions of the QTL
      a<-subset(cross_file, chr=c) # Subset the chromosomes where QTL are found
       
      # Simulate the genome for that subset
      a <- sim.geno(a, 
                    n.draws = 128, 
                    step = 2, 
                    off.end = 0.0, 
                    error.prob = 1.0e-4, 
                    map.function = "kosambi", 
                    stepwidth = "fixed") 
       
      # Make a QTL object from that subset
      madeqtl <- makeqtl(a, 
                         c, 
                         p, 
                         qtl.name = qtl[,4], 
                         what = c("prob")) 
   
      # Place that QTL object in a list
      results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- madeqtl 
      print("Done")
      
      # Announce
      print("Running drop-one QTL analysis...")
       
      # Test the significance of those QTL using dropone analysis
      qtlfit <- fitqtl(cross_file, 
                       qtl = madeqtl, 
                       pheno.col = i, 
                       get.ests = T,
                       model = "normal", 
                       method = "hk") 
      
      # Check results
      if(!is.null(qtlfit$result.drop)){
        # Announce
        print("Checking drop-one analysis for significance")
        
        # Make a dataframe of the drop results
        a <- as.data.frame(qtlfit$result.drop)
        
        # Check significance 
        a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
        
        # Check significance 
        a <- data.frame(name=rownames(a[a$sig==0,]))
        
        # Separate the column name into sections 
        a <- tidyr::separate(data = a, 
                             col = "name",
                             into = c("chr", "trash", "pos"),
                             sep = "-")
        
        # Make sure position is a number
        a$pos <- as.numeric(a$pos)
        
        # Make the chromosome object from the trait
        a$chr <- gsub(paste("MQM", j, "_", sep = ""),"",a$chr)
        
        # Drop the insignificant QTL from the object
        madeqtl <- dropfromqtl(madeqtl,
                               chr = a$chr,
                               pos = a$pos)
        
        # Add the significant QTL to the object
        madeqtl <- addtoqtl(cross_file,
                            qtl = madeqtl,
                            chr = qtl_check$chr,
                            pos = qtl_check$pos,
                            qtl.name = qtl_check$name)
              
        
        # Add this QTL object to the list of list
        results[[paste("MQM", j, sep="")]]$qtl[[i]] <- madeqtl 
        
        # Remove temporary dataframes
        remove(a, c, p)
        }else{
          # Announce 
          print(paste("There was only one new QTL identified for ",
                      i,
                      " in ", 
                      paste("MQM", j, sep = ""),
                      "... Checking significance!",
                      sep = ""))
          
          # If this QTL is significant
          if(qtlfit$result.full[1,6]<0.05){
            # Announce
            print("New QTL is significant, placing in total model!")
            
            # Add that significant peak to the QTL object
            madeqtl <- addtoqtl(cross_file,
                                qtl = madeqtl,
                                chr = qtl_check$chr,
                                pos = qtl_check$pos,
                                qtl.name = qtl_check$name)
            
            # Add the object to the list of list
            results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- madeqtl 
            }else{
              # Make the multiple QTL model NULL
              results[[paste("MQM", j, sep = "")]]$qtl[[i]] <- NULL 
              
              # Announce
              print(paste("There were no new QTL identified for", i, "concluding loop."))
              
              # Break loop 
              break
            }
          }
        }
      
    
    # Add result to object to check
    qtl_check <- results[[paste("MQM", j, sep="")]]$qtl[[i]]
    
    # Add 1 to the j vector to indicate what round we are on
    j=j+1
  }
  
  # Check
  if(j-1==0){
    # Pull and make final qtl object
    finalqtl <- results$IM$qtl[[i]]
  }else{
    # Pull and make final qtl object
    finalqtl <- results[[paste("MQM", j-1, sep="")]]$qtl[[i]]
      
  }
  
  # Check for significance
  qtlfit <- fitqtl(cross_file, 
                   qtl = finalqtl, 
                   pheno.col = i, 
                   get.ests = T,
                   model = "normal", 
                   method = "hk") 
  
  # Rename the QTL
  a <- finalqtl
  a <- data.frame(summary(a))
  a <- tidyr::separate(a, col = "name", into=c("model", "trash"), sep = "_")
  a$name <- paste(a$model, "_", a$chr, "-pos-", a$pos, sep = "")
  finalqtl$name = a$name
  remove(a)
  
  # Announce
  print("Filtering insignificant markers...")
  
  # If there are drop one analysis results
  if(!is.null(qtlfit$result.drop)){
    # Pull results into a dataframe
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the significant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Select the insignificant markers 
    a <- data.frame(name=rownames(a[a$sig==0,]))
    
    # Remove those QTL from the final QTL object
    finalqtl <- dropfromqtl(finalqtl,
                            qtl.name = a$name)
    
    # Add this to the list of list
    results$final$qtl_unrefine[[i]] <- finalqtl 
    
    # Remove the object
    remove(a, finalqtl)
  }else{
    # Put the final object in the list of list
    results$final$qtl_unrefine[[i]] <- finalqtl
    
    # Remove the object finalqtl
    remove(finalqtl)
  }
   
  # Announce
  print("Refining QTL position...")
  
  # Refine the QTL with the refine 
  results$final$qtl_refine[[i]] <- refineqtl(cross = cross_file, 
                                             pheno.col = i, 
                                             qtl = results$final$qtl_unrefine[[i]], 
                                             verbose = FALSE,
                                             method = "hk")
  # Rename the QTL
  a <- results$final$qtl_refine[[i]]
  a <- data.frame(summary(a))
  a <- tidyr::separate(a, col = "name", into=c("model", "trash"), sep = "_")
  a$name <- paste(a$model, "_", a$chr, "-pos-", a$pos, sep = "")
  results$final$qtl_refine[[i]]$name <- a$name
  remove(a)
  
  # Final significance check
  qtlfit <- fitqtl(cross_file, 
                   qtl = results$final$qtl_refine[[i]], 
                   pheno.col = i, 
                   get.ests = T,
                   model = "normal", 
                   method = "hk") 
  
  # Put the final QTL object into finalqtl
  finalqtl <- results$final$qtl_refine[[i]]
  
  # If there are drop one analysis results
  if(!is.null(qtlfit$result.drop)){
    # Pull results into a dataframe
    a <- as.data.frame(qtlfit$result.drop)
    
    # Find the significant QTL
    a$sig <- ifelse(a$`Pvalue(F)`<0.05, 1, 0)
    
    # Select the insignificant markers 
    a <- data.frame(name=rownames(a[a$sig==0,]))
    
    # Remove those QTL from the final QTL object
    finalqtl <- dropfromqtl(finalqtl,
                            qtl.name = a$name)
    
    # Add this to the list of list
    results$final$qtl_refine_filt[[i]] <- finalqtl 
    
    # Remove the object
    remove(a, finalqtl)
  }else{
    # Put the final object in the list of list
    results$final$qtl_refine_filt[[i]] <- finalqtl
    
    # Remove the object finalqtl
    remove(finalqtl)
  }
   
  # Create an object for support LOD internvals 
  droplodint<-c()
  
  #create QTL 1.5 drop LOD intervals
  for(z in results$final$qtl_refine_filt[[i]]$name){
    # Pull data for specific QTL
    a <- data.frame(name = z)
    
    # Pull the scan name 
    a <- tidyr::separate(data = a,
                         col = "name",
                         into = c("scan", "other"),
                         sep = "_",
                         remove = FALSE)
    
    # Pull the position name
    a <- tidyr::separate(data = a,
                         col = "other",
                         into = c("chr", "trash", "pos"),
                         sep = "-",
                         remove = TRUE)
    
    # Pull the relevant scan 
    b <- results[[a$scan]]$scan[[i]]
    
    # Find the nearest sudo marker to the LOD peak
    c <- find.pseudomarker(cross = cross_file,
                           chr = a$chr,
                           pos = as.numeric(a$pos))
    
    # Pull the confidence interval for 1.5 LOD drop
    d <- lodint(results = b,
                chr = a$chr,
                qtl.index = c,
                drop = 1.5,
                lodcolumn = 1,
                expandtomarkers = TRUE)
    
    # Create a dataframe with that data
    d <- data.frame(name = z, 
                    trait = i,
                    chr = unique(d$chr),
                    start_marker = rownames(d)[1],
                    start = d[1,2], 
                    mid_marker = rownames(d)[2],
                    mid_pos = d[2,2],
                    stop_marker = rownames(d)[3],
                    stop = d[3,2])
    
    # Bind into lodint object
    droplodint <- rbind(droplodint, d)
    
    # Remove temporary data
    remove(a,b,c,d)
  }
  
  # Place in results
  results$final$qtl_support_intervals[[i]] <- droplodint
  
  # Remove
  remove(droplodint)
  
}

# Rename results
results_VR_FDK_DON <- results

# Remove results
remove(results)
```

# Visualize FHB, FDK, and DON QTL 

```{r}
#make object for ggplot
traits <- names(cross_file$pheno)[c(grep("VR", names(cross_file$pheno)),
                                    grep("FDK", names(cross_file$pheno)),
                                    grep("DON", names(cross_file$pheno)))]

# Make a color pallet
color_palette <- c(
  # "HD_ME" = "#0000FF",        # Blue
  # "HD_RAL19" = "#2F4F4F",     # DarkSlateGray
  # "HD_RAL20" = "#00FFFF",     # Cyan
  # "HD_KIN20" = "#1E90FF",     # DodgerBlue
  # "HD_WAR20" = "#5F9EA0",     # CadetBlue
  # "PH_ME" = "#EE82EE",        # Violet
  # "PH_RAL20" = "#BA55D3",     # MediumOrchid
  # "PH_KIN20" = "#9932CC",     # DarkOrchid
  "VR_ME" = "#FF0000",        # Red
  "VR_KIN19" = "#8B0000",     # DarkRed
  "VR_KIN20" = "#B22280",     # Firebrick
  "VR_RAL19" = "#A0522D",     # Brown
  "VR_RAL20" = "#FF4500",     # OrangeRed
  "VR_WAR20" = "#FF6347",     # Tomato
  "FDK_ME" = "#E6CC00",       # Yellow
  "FDK_KIN19" = "#B8860B",    # DarkGoldenrod
  "FDK_KIN20" = "#FFD700",    # Gold
  "FDK_RAL19" = "#DAA520",    # Goldenrod
  "FDK_RAL20" = "#F0E68C",    # Khaki
  "FDK_WAR19" = "#EEE8AA",    # PaleGoldenrod
  "FDK_WAR20" = "#8B864E",    # Khaki4
  "DON_ME" = "#00FF00",       # DarkGreen
  "DON_KIN19" = "#66CD00",    # Chartreuse3
  "DON_KIN20" = "#556B2F",    # DarkOliveGreen
  "DON_RAL19" = "#8FBC8F",    # DarkSeaGreen
  "DON_RAL20" = "#6B8E23",    # OliveDrab
  "DON_WAR19" = "#98FB98",    # PaleGreen
  "DON_WAR20" = "#00FF7F"     # SpringGreen1
)

# Run function
finalplot <- qtl_visualization(results_data = results_VR_FDK_DON,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = c("1A", "3A", "5A", "7D"),
                               label_size = 5)

# Create final plot
a <- (finalplot$chr_1A+
        finalplot$chr_2A+
        finalplot$chr_2B+
        finalplot$chr_2D+
        finalplot$chr_3A+
        finalplot$chr_3B+
        finalplot$chr_4A+
        finalplot$chr_4B+
        finalplot$chr_5A+
        finalplot$chr_5B+
        finalplot$chr_6B+
        finalplot$chr_7A+
        finalplot$chr_7D)+
    plot_layout(guides = "collect", nrow = 4)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Visual Rating (VR), Fusarium Damaged Kernels (FDK), and Deoxynivalenol Content (DON)") &
  theme(legend.position='bottom',
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        title = element_text(size = 20),
        text = element_text(size = 20))

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_vr_fdk_don_with_adjustment.jpg",
       width = 20,
       height = 15,
       dpi = 320,
       units = "in")
```

# Visualize FHB, FDK, and DON QTL for ME only

```{r}
# Pull traits
traits<-c("VR_ME", "FDK_ME", "DON_ME")

# Make a color pallet
color_palette <- c(
  # "Heading Date" = "#0000FF",                # Blue
  # "Plant Height" = "#EE82EE",                # Violet
  "Visual Rating" = "#FF0000",                 # Red  
  "Fusarium Damaged Kernels" = "#E6CC00",      # Yellow
  "Deoxynivalenol Content" = "#00FF00"         # Green
)


# Make temp
temp1 <- results_VR_FDK_DON

# Rename
temp1$final$qtl_support_intervals$VR_ME$trait <- "Visual Rating"
temp1$final$qtl_support_intervals$FDK_ME$trait <- "Fusarium Damaged Kernels"
temp1$final$qtl_support_intervals$DON_ME$trait <- "Deoxynivalenol Content"

# Run function
finalplot <- qtl_visualization(results_data = temp1,
                               color_palette = color_palette,
                               traits = traits,
                               y_axis = c("1A", "3A", "5A"),
                               label_size = 6)

# Remove temp
remove(temp1)

# Create final plot
a <- (finalplot$chr_1A+
        finalplot$chr_2A+
        finalplot$chr_2B+
        finalplot$chr_3A+
        finalplot$chr_3B+
        finalplot$chr_4A+
        finalplot$chr_5A+
        finalplot$chr_5B+
        finalplot$chr_7A+
        finalplot$chr_7D)+
    plot_layout(guides = "collect", nrow = 3)+
    plot_annotation(title = "1.5-LOD Support Intervals",
                    subtitle = "Visual Rating (VR), Fusarium Damaged Kernels (FDK), and Deoxynivalenol Content (DON)")&
  theme(legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        title = element_text(size = 20),
        text = element_text(size = 20))

# Visualize final plot
a

# Save output
ggsave(plot = a,
       filename = "support_intervals_vr_fdk_don_with_adjustment_ME_only.jpg",
       width = 20,
       height = 15,
       dpi = 320,
       units = "in")
```

# Percent variance calculations - VR, FDK, and DON with adjustment

```{r}
# Pull all traits
traits <- names(cross_file$pheno)[c(grep("VR", names(cross_file$pheno)),
                                    grep("FDK", names(cross_file$pheno)),
                                    grep("DON", names(cross_file$pheno)))]

# Make an object for support interval
final_qtls <- c()

# For i in trait names
for(i in traits){
  # Pull temporary dataframe
  a <- results_VR_FDK_DON$final$qtl_support_intervals[[i]]
  
  # Format final QTL object
  final_qtls <- rbind(final_qtls, a)
  
  # Remove final object
  remove(a)
}

# Make an object for information
qtl_info_drop_one_adj <- c()
qtl_info_full_adj <- c()

# For i in final_qtls object
for(i in traits){
  # Pull data
  a <- results_VR_FDK_DON$final$qtl_refine_filt[[i]]
  
  # If a is NULL
  if(is.null(a)){
    # Move to next trait
    next
  }
  
  # Fit QTL
  b <- fitqtl(cross_file, 
              qtl =results_VR_FDK_DON$final$qtl_refine_filt[[i]], 
              pheno.col = i, 
              get.ests = T,
              model = "normal", 
              method = "hk") 
  
  # Get full model
  c <- as.data.frame(b$result.full)
  
  # Move effect into column name
  c$effect <- rownames(c)
  rownames(c) <- NULL
  
  # Get drop one 
  d <- as.data.frame(b$result.drop)
  
  # Move QTL name into column
  d$name <- rownames(d)
  rownames(d) <- NULL
  
  # Get effect estimates
  d <- left_join(d,
                 data.frame(name = names(b$ests$ests), 
                            est_effect = b$ests$ests),
                 by = "name") 

  
  # Bind in data
  e <- results_VR_FDK_DON$final$qtl_support_intervals[[i]]
  
  # Left join
  d <- left_join(d, e, by = "name")
  
  # Add trait names to both full model
  c$trait <- i
  
  # Bind in data
  qtl_info_drop_one_adj <- rbind(qtl_info_drop_one_adj, d)
  qtl_info_full_adj <- rbind(qtl_info_full_adj, c)
  
  # Remove
  remove(a,b,c,d,e)
}


# Write file
write.csv(qtl_info_drop_one_adj,
          "vr_fdk_don_drop_one_qtl_info_with_adjustment.csv",
          row.names = FALSE)

# Write file
write.csv(qtl_info_full_adj,
          "vr_fdk_don_full_model_qtl_info_with_adjustment.csv",
          row.names = FALSE)
```


# Create marker table

```{r}
# First report
GAWN_2015 <- readxl::read_excel("2015 5ST MDXN GAWN SUN Marker Report.xlsx",
                                sheet = "Table 1.4 GAWN Summary",
                                skip = 4,
                                .name_repair = 'minimal')
GAWN_2015 <- GAWN_2015[, colSums(is.na(GAWN_2015)) != nrow(GAWN_2015)]
GAWN_2015 <- GAWN_2015[,-c(1:4)]
GAWN_2015 <- as.data.frame(GAWN_2015[GAWN_2015$`Cultivar/Designation`=="GA06493-13LE6",])

# Second report
SUWWSN_2016 <- readxl::read_excel("2016 NUWWSN PNUWWSN SUWWSN Marker Report.xlsx",
                                  sheet = "Table 1.3 SUWWSN summary",
                                  skip = 4,
                                  .name_repair = 'minimal')
SUWWSN_2016 <- SUWWSN_2016[, colSums(is.na(SUWWSN_2016)) != nrow(SUWWSN_2016)]
SUWWSN_2016 <- SUWWSN_2016[,-c(1:4)]
SUWWSN_2016 <- as.data.frame(SUWWSN_2016[SUWWSN_2016$`Cultivar/Designation`=="NC13-20076",])

# Select calls
GAWN_2015 <- GAWN_2015[,c(1, 
                          grep("RHT", colnames(GAWN_2015), ignore.case = TRUE),
                          grep("PPD", colnames(GAWN_2015), ignore.case = TRUE),
                          grep("VRN", colnames(GAWN_2015), ignore.case = TRUE))]
SUWWSN_2016 <- SUWWSN_2016[,c(1, 
                              grep("RHT", colnames(SUWWSN_2016), ignore.case = TRUE),
                              grep("PPD", colnames(SUWWSN_2016), ignore.case = TRUE),
                              grep("VRN", colnames(SUWWSN_2016), ignore.case = TRUE))]

# Format
GAWN_2015 <- GAWN_2015[1,c(1:6, 9:ncol(GAWN_2015))] 
GAWN_2015[1,1:ncol(GAWN_2015)] <- c("GA06493-13LE6",
                                    "Wild Type",
                                    "Dwarf",
                                    "Photoperiod Sensitive", 
                                    "Photoperiod Sensitive",
                                    "Photoperiod Insensitive",
                                    "Long Vernalization",
                                    "Long Vernalization",
                                    "Long Vernalization")
SUWWSN_2016 <- SUWWSN_2016[1,c(1:6, 10:ncol(SUWWSN_2016))]
SUWWSN_2016[1,] <- c("NC13-20076",
                     "Wild Type",
                     "Dwarf",
                     "Photoperiod Sensitive", 
                     "Photoperiod Sensitive",
                     "Photoperiod Insensitive",
                     "Short Vernalization (2 Copies)",
                     "Long Vernalization",
                     "Long Vernalization")

# Marker Report
marker_report <- rbind(SUWWSN_2016, GAWN_2015)
marker_report <- as.data.frame(t(marker_report))
colnames(marker_report) <- marker_report[1,]
marker_report <- marker_report[-1,]
marker_report$Gene <- rownames(marker_report)
marker_report <- marker_report[, c("Gene", "NC13-20076", "GA06493-13LE6")]
rownames(marker_report) <- NULL
write.csv(marker_report,
          "parental_marker_report.csv",
          row.names = FALSE)
```

# Create HD and PH QTL Table

```{r}
# Read table
hd_ph_vr_fdk_don_table <- read.csv("hd_ph_vr_fdk_don_drop_one_qtl_info_no_adjustment.csv",
                                   check.names = FALSE)

# Subset data
hd_ph_vr_fdk_don_table <- hd_ph_vr_fdk_don_table %>%
  select(name, 
         trait, 
         chr, 
         start_marker,
         start,
         mid_marker,
         mid_pos,
         stop_marker,
         stop,
         LOD,
         `%var`,
         est_effect) %>%
  arrange(trait, chr, mid_pos)

# Make edit
hd_ph_vr_fdk_don_table_edit <-c()

# Loop
for(i in unique(hd_ph_vr_fdk_don_table$trait)){
  # Pull the trait
  temp1 <- hd_ph_vr_fdk_don_table[hd_ph_vr_fdk_don_table$trait==i,]
  
  # Loop 
  for(j in unique(temp1$chr)){
    # Pull all loci for that chromosome
    temp2 <- temp1[temp1$chr==j, ]
    
    # Make string for multiple QTL
    if(length(temp2$name) > 1){
      temp2.1 <- paste(".", seq(1:length(temp2$name)), sep = "") 
    }else{
      temp2.1 <- ""
    }
    
    # Rename the QTL based on location and trait
    temp2$name <- paste("Q",
                        ifelse(grepl("PH", unique(temp2$trait), ignore.case = TRUE),
                               "Pht",
                               ifelse(grepl("HD", unique(temp2$trait), ignore.case = TRUE),
                                      "Hd",
                                      ifelse(grepl("VR", unique(temp2$trait), ignore.case = TRUE),
                                             "Fvr",
                                             ifelse(grepl("FDK", unique(temp2$trait), ignore.case = TRUE),
                                                    "Fdk",
                                                    ifelse(grepl("DON", unique(temp2$trait), ignore.case = TRUE),
                                                           "Don",
                                                           "ERROR"))))),
                        ".nc-",
                        j,
                        temp2.1,
                        sep = "")
    
    # Remove string
    remove(temp2.1)
    
    # Loop 
    for (k in unique(temp2$name)){
      # Pull data
      temp2.2 <- temp2[temp2$name==k, "mid_marker"]
      
      # If the mid_marker is a sudo-position
      if(grepl("loc", temp2.2, ignore.case = TRUE)){
        temp2[temp2$name==k, "mid_marker"] <- find.marker(cross = cross_file,
                                                          chr = temp2[temp2$name==k, "chr"],
                                                          pos = temp2[temp2$name==k, "mid_pos"])
      }
      
      # Remove
      remove(temp2.2)
    }
    
    # Add to new dataframe
    if(j==unique(temp1$chr)[1]){
      # Make new dataframe
      temp3 <- temp2
      
      # Remove
      remove(temp2)
    }else{
      # Bind onto new dataframe
      temp3 <- rbind(temp3, temp2)
      
      # Remove
      remove(temp2)
    }
  }
  
  # Rename 
  temp3 <- temp3 %>%
    separate(trait, into = c("Trait", "Environment"), sep = "_",  remove = TRUE) %>%
    separate(start_marker, into = c("temp1", "Left Position (Mbp)"), sep = "_", remove = FALSE) %>%
    separate(mid_marker, into = c("temp2", "Peak Position (Mbp)"), sep = "_", remove = FALSE) %>%    
    separate(stop_marker, into = c("temp3", "Right Position (Mbp)"), sep = "_", remove = FALSE) %>%
    rename(QTL = name,
           Chromosome = chr,
           `Left Marker` = start_marker,
           `Left Position (cM)` = start,
           `Peak Marker` = mid_marker,
           `Peak Position (cM)` = mid_pos,
           `Right Marker` = stop_marker,
           `Right Position (cM)` = stop,
           PV = `%var`,
           Effect = est_effect) %>%
    mutate(`Left Position (Mbp)` = round(as.numeric(`Left Position (Mbp)`)/1000000, 1),
           `Peak Position (Mbp)` = round(as.numeric(`Peak Position (Mbp)`)/1000000, 1),
           `Right Position (Mbp)` = round(as.numeric(`Right Position (Mbp)`)/1000000, 1),
           `Left Position (cM)` = round(`Left Position (cM)`, 1),
           `Peak Position (cM)` = round(`Peak Position (cM)`, 1),
           `Right Position (cM)` = round(`Right Position (cM)`, 1)) %>%
    select(QTL, 
           Trait,
           Environment, 
           Chromosome,
           `Left Marker`,
           `Left Position (cM)`,
           `Left Position (Mbp)`,           
           `Peak Marker`,
           `Peak Position (cM)`,
           `Peak Position (Mbp)`,
           `Right Marker`,
           `Right Position (cM)`,
           `Right Position (Mbp)`,
           LOD,
           PV,
           Effect)
  
  # Bind in
  hd_ph_vr_fdk_don_table_edit <- rbind(hd_ph_vr_fdk_don_table_edit,
                                       temp3)
  
  # Remove
  remove(temp1, temp3)

}

# Order
hd_ph_vr_fdk_don_table_edit <- hd_ph_vr_fdk_don_table_edit %>%
  arrange(Trait, Environment, Chromosome, `Peak Position (cM)`)

# Write full table
write.csv(hd_ph_vr_fdk_don_table_edit,
          "hd_ph_vr_fdk_don_drop_one_qtl_info_no_adjustment_formatted.csv",
          row.names = FALSE)

# Subset only PH and HD
hd_ph_table <- hd_ph_vr_fdk_don_table_edit %>%
  filter(Trait %in% c("HD", "PH"))

# Subset only ME
hd_ph_table_me <- hd_ph_table %>%
  filter(Environment=="ME") %>%
  arrange(Trait, Chromosome, `Peak Position (cM)`) %>%
  select(-Trait, -Environment)

# Get counts across environments
counts <- hd_ph_table %>%
  filter(Environment!="ME") %>%
  count(QTL)

# Bind in those counts
hd_ph_table_me <- hd_ph_table_me %>%
  left_join(counts, by = "QTL") %>%
  rename(N = n) %>%
  select(QTL, N, everything())

# Write table
write.csv(hd_ph_table_me,
          "hd_ph_me_formatted.csv",
          row.names = FALSE)
```

# Create VR, FDK, and DON table

```{r}
# Read table
vr_fdk_don_table <- read.csv("vr_fdk_don_drop_one_qtl_info_with_adjustment.csv",
                             check.names = FALSE)

# Subset data
vr_fdk_don_table <- vr_fdk_don_table %>%
  select(name, 
         trait, 
         chr, 
         start_marker,
         start,
         mid_marker,
         mid_pos,
         stop_marker,
         stop,
         LOD,
         `%var`,
         est_effect) %>%
  arrange(trait, chr, mid_pos)

# Make edit
vr_fdk_don_table_edit <-c()

# Loop
for(i in unique(vr_fdk_don_table$trait)){
  # Pull the trait
  temp1 <- vr_fdk_don_table[vr_fdk_don_table$trait==i,]
  
  # Loop 
  for(j in unique(temp1$chr)){
    # Pull all loci for that chromosome
    temp2 <- temp1[temp1$chr==j, ]
    
    # Make string for multiple QTL
    if(length(temp2$name) > 1){
      temp2.1 <- paste(".", seq(1:length(temp2$name)), sep = "") 
    }else{
      temp2.1 <- ""
    }
    
    # Rename the QTL based on location and trait
    temp2$name <- paste("Q",
                        ifelse(grepl("PH", unique(temp2$trait), ignore.case = TRUE),
                               "Pht",
                               ifelse(grepl("HD", unique(temp2$trait), ignore.case = TRUE),
                                      "Hd",
                                      ifelse(grepl("VR", unique(temp2$trait), ignore.case = TRUE),
                                             "Fvr",
                                             ifelse(grepl("FDK", unique(temp2$trait), ignore.case = TRUE),
                                                    "Fdk",
                                                    ifelse(grepl("DON", unique(temp2$trait), ignore.case = TRUE),
                                                           "Don",
                                                           "ERROR"))))),
                        ".nc-",
                        j,
                        temp2.1,
                        sep = "")
    
    # Remove string
    remove(temp2.1)
    
    # Loop 
    for (k in unique(temp2$name)){
      # Pull data
      temp2.2 <- temp2[temp2$name==k, "mid_marker"]
      
      # If the mid_marker is a sudo-position
      if(grepl("loc", temp2.2, ignore.case = TRUE)){
        temp2[temp2$name==k, "mid_marker"] <- find.marker(cross = cross_file,
                                                          chr = temp2[temp2$name==k, "chr"],
                                                          pos = temp2[temp2$name==k, "mid_pos"])
      }
      
      # Remove
      remove(temp2.2)
    }
    
    # Add to new dataframe
    if(j==unique(temp1$chr)[1]){
      # Make new dataframe
      temp3 <- temp2
      
      # Remove
      remove(temp2)
    }else{
      # Bind onto new dataframe
      temp3 <- rbind(temp3, temp2)
      
      # Remove
      remove(temp2)
    }
  }
  
  # Rename 
  temp3 <- temp3 %>%
    separate(trait, into = c("Trait", "Environment"), sep = "_",  remove = TRUE) %>%
    separate(start_marker, into = c("temp1", "Left Position (Mbp)"), sep = "_", remove = FALSE) %>%
    separate(mid_marker, into = c("temp2", "Peak Position (Mbp)"), sep = "_", remove = FALSE) %>%    
    separate(stop_marker, into = c("temp3", "Right Position (Mbp)"), sep = "_", remove = FALSE) %>%
    rename(QTL = name,
           Chromosome = chr,
           `Left Marker` = start_marker,
           `Left Position (cM)` = start,
           `Peak Marker` = mid_marker,
           `Peak Position (cM)` = mid_pos,
           `Right Marker` = stop_marker,
           `Right Position (cM)` = stop,
           PV = `%var`,
           Effect = est_effect) %>%
    mutate(`Left Position (Mbp)` = round(as.numeric(`Left Position (Mbp)`)/1000000, 1),
           `Peak Position (Mbp)` = round(as.numeric(`Peak Position (Mbp)`)/1000000, 1),
           `Right Position (Mbp)` = round(as.numeric(`Right Position (Mbp)`)/1000000, 1),
           `Left Position (cM)` = round(`Left Position (cM)`, 1),
           `Peak Position (cM)` = round(`Peak Position (cM)`, 1),
           `Right Position (cM)` = round(`Right Position (cM)`, 1)) %>%
    select(QTL, 
           Trait,
           Environment, 
           Chromosome,
           `Left Marker`,
           `Left Position (cM)`,
           `Left Position (Mbp)`,           
           `Peak Marker`,
           `Peak Position (cM)`,
           `Peak Position (Mbp)`,
           `Right Marker`,
           `Right Position (cM)`,
           `Right Position (Mbp)`,
           LOD,
           PV,
           Effect)
  
  # Bind in
  vr_fdk_don_table_edit <- rbind(vr_fdk_don_table_edit,
                                 temp3)
  
  # Remove
  remove(temp1, temp3)
}

# Order
vr_fdk_don_table_edit <- vr_fdk_don_table_edit %>%
  arrange(Trait, Environment, Chromosome, `Peak Position (cM)`)

# Write full table
write.csv(vr_fdk_don_table_edit,
          "vr_fdk_don_drop_one_qtl_info_with_adjustment_formatted.csv",
          row.names = FALSE)

# Subset only single environments
vr_fdk_don_table <- vr_fdk_don_table_edit %>%
  filter(Environment!="ME") %>%
  count(QTL)

# Subset only ME
vr_fdk_don_table_me <- vr_fdk_don_table_edit %>%
  filter(Environment=="ME") %>%
  arrange(Trait, Chromosome, `Peak Position (cM)`) %>%
  select(-Trait, -Environment)

# Bind in those counts
vr_fdk_don_table_me <- vr_fdk_don_table_me %>%
  left_join(vr_fdk_don_table, by = "QTL") %>%
  rename(N = n) %>%
  select(QTL, N, everything())

# Perform multiple marker regression for the ME QTL
for(i in c("VR", "FDK", "DON")){
  # Pull peak markers for QTL
  temp1 <- vr_fdk_don_table_me[grep(i, vr_fdk_don_table_me$QTL, ignore.case = TRUE),"Peak Marker"]
  
  # Name the QTL
  names(temp1) <- vr_fdk_don_table_me[grep(i, vr_fdk_don_table_me$QTL, ignore.case = TRUE),"QTL"]
  
  # Pull those markers
  temp2 <- as.data.frame(pull.geno(fill.geno(cross_file))[,temp1])

  # Replace 1 and 2 with A and B
  temp2[temp2==1] <- "A"
  temp2[temp2==2] <- "B"
    
  # Make all columns a factor
  temp2[,1:ncol(temp2)] <- lapply(temp2[,1:ncol(temp2)], as.factor)
  
  # Colnames rename
  colnames(temp2) <- names(temp1)
  
  # Add GENOTYPE
  temp2$GENOTYPE <- as.character(cross_file$pheno$GENOTYPE)
  
  # Left join phenotype data
  temp2 <- left_join(temp2, na.omit(pheno[,c("GENOTYPE", ifelse(i=="VR", "FHB", i))]), by = "GENOTYPE")
  
  # Make formula
  temp3 <- formula(paste("temp2[,length(temp1)+2] ~", paste("temp2[,", 1:length(temp1), "]", sep = "", collapse = " + "), sep = " "))
  
  # Make equation
  temp4 <- lm(temp3)
  
  # Pull effect estimate
  temp5 <- data.frame(QTL = names(temp1),
                      `Unadjusted Effect` = temp4$coefficients[2:c(length(temp1)+1)],
                      row.names = NULL)
  
  # Put into vector 
  if(i=="VR"){
    # Unadjusted effects vector
    unadjusted_effects <- temp5
  }else{
    # Rbind
    unadjusted_effects <- rbind(unadjusted_effects, temp5)
  }
  
  # Clean up
  remove(temp1, temp2, temp3, temp4, temp5)
}

# Bind in
vr_fdk_don_table_me <- vr_fdk_don_table_me %>%
  left_join(unadjusted_effects, by = "QTL")

# Write table
write.csv(vr_fdk_don_table_me,
          "vr_fdk_don_me_formatted.csv",
          row.names = FALSE)
```

# Create summary table for traits

```{r}
# Create table and write out
temp1 <- data.frame(t(BLUEs_all_summary[,1:6]))
colnames(temp1) <- temp1[1,]
temp1 <- temp1[-1,-7]
temp1 <- rownames_to_column(temp1, var = "Trait")
temp1$Trait <- c("Visual Ratings", "Fusarium Damaged Kernels", "DON Content", "Heading Date", "Plant Height")
temp1$SD <- c(sd(BLUEs_mem$FHB_ME, na.rm = TRUE),
              sd(BLUEs_mem$FDK_ME, na.rm = TRUE),
              sd(BLUEs_mem$DON_ME, na.rm = TRUE),
              sd(BLUEs_mem$HD_ME, na.rm = TRUE),
              sd(BLUEs_mem$PH_ME, na.rm = TRUE))
temp1 <- cbind(temp1, t(BLUEs_mem[BLUEs_mem$GENOTYPE %in% c("13955-GA06493-13LE6", "13955-NC13-20076"), 2:6]))
colnames(temp1)[9:10] <- c("GA06493-13LE6", "NC13-20076")
temp1 <- temp1 %>% 
  select(Trait, Minimum, Mean, Maximum, SD, `NC13-20076`, `GA06493-13LE6`)
rownames(temp1) <- NULL  
write.csv(temp1,
          "formatted_summary_statistics.csv",
          row.names = FALSE)
remove(temp1)
```

# Move all files to relevant folders 

```{r}
# Create directory
target_directory <- paste(getwd(), "results_images", sep = "/")
dir.create(target_directory, showWarnings = FALSE)

# Get a list of files that are images
files <- list.files()[grep("\\.jpg", list.files(), ignore.case = TRUE)]

# Move into folder
for(i in files){
  # Get working directory
  temp1 <- paste(getwd(), i, sep = "/")
  
  # Get target directory 
  temp2 <- paste(target_directory, i, sep = "/")
  
  # Move the file
  file.rename(from = temp1,
              to = temp2)
  
  # Remove
  remove(temp1, temp2)
}

# Create directory
target_directory <- paste(getwd(), "results_csv_files", sep = "/")
dir.create(target_directory, showWarnings = FALSE)

# Get a list of files that are images
files <- list.files()[grep("\\.csv", list.files(), ignore.case = TRUE)]
files <- files[!files %in% c("list_of_potential_selfs.csv",
                             "NC13955_Combined_Data_Final.csv")]

# Move into folder
for(i in files){
  # Get working directory
  temp1 <- paste(getwd(), i, sep = "/")
  
  # Get target directory 
  temp2 <- paste(target_directory, i, sep = "/")
  
  # Move the file
  file.rename(from = temp1,
              to = temp2)
  
  # Remove
  remove(temp1, temp2)
}
```

# Make markdowns of supplemental material

## Supplemental Information 1

```{r}
markdown_content <- c("
---
title: \"Supplemental Information 1\"
output: pdf_document
---

## Description

List of major loci which affect plant height and heading date. For reduced height genes (e.g., _Rht_), wild type refers to the tall allele at the locus and dwarf refers to the dwarfing allele (e.g., _Rht-B1b_). For photoperiod genes (e.g., _Ppd_), photoperiod-sensitive means that the line has the allele which encodes response to day length and photoperiod-insensitive means the line has the allele which leads to a lack of response to day length. For vernalization genes (e.g., _Vrn_), long vernalization refers to the three-copy haplotype at the locus and short vernalization indicates the two-copy haplotype at the locus.

```{r, echo=FALSE}
a <- read.csv('./results_csv_files/parental_marker_report.csv', check.names = FALSE)
knitr::kable(a, align = 'c')
```")

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_1.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_1.Rmd", output_format = "pdf_document")
```

## Supplemental Information 2

```{r}
markdown_content <- c("
---
title: \"Supplemental Information 2\"
output: pdf_document
---

## Description

Visualization of linkage-map marker centimorgan (cM) versus megabase pair (Mbp) distance. Each subgraph header displays the name of each linkage group (chromosome). The x-axis displays the physical Mbp distance between markers. The y-axis displays the recombination-based cM distance between markers.

\\pagebreak

![](\\./results_images/cM_vs_bp_comparison.jpg)

")

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_2.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_2.Rmd", output_format = "pdf_document")
```

## Supplemental Information 3

```{r}
# Create the Markdown content
markdown_content <- c("
---
title: \"Supplemental Information 3\"
output: 
  pdf_document:
    extra_dependencies: [\"geometry\"]
    latex_engine: xelatex
geometry: landscape
---

## Description

Interval mapping (IM) and multiple quantitative-trait-locus mapping (MQM) scans for heading date (HD) and plant height (PH), Fusarium head blight (FHB) visual ratings (VR), Fusarium-damaged kernels (FDK), and deoxynivalenol (DON) quantitative trait loci (QTL). Presented are the results of scans performed without heading date and plant height marker covariates. In the title of each graph appears the type of scan (IM vs MQM) and the trait which the scan belongs to. Environments assessed include: Kinston, NC 2019 (KIN19) and 2020 (KIN20); Raleigh, NC 2019 (RAL19) and 2020 (RAL20); Warsaw, VA 2019 (WAR19) and 2020 (WAR20); and multi-environment (ME). The number following MQM titles indicates which round of MQM the scan belongs to (e.g., MQM 2 is the second round of multiple QTL mapping). The y-axis displays the likelihood of odds (LOD) score of every position across the genome. The dotted line denotes the 1,000-permutation significance threshold at alpha = 0.05. If the significance threshold is not displayed in the graph, all peaks detected in the QTL scan were below the significance threshold. This is usually apparent in the last MQM scan performed. The x-axis displays each linkage group, designated by their corresponding chromosome names (e.g., 1A, 1B, 1D, etc.). The rug of hash marks denotes the cM position of each marker in the recombination map. All information regarding location, LOD and effect appears at the end of the document.

\\pagebreak

")

# Pull all traits
traits <- names(cross_file$pheno)[c(grep("HD", names(cross_file$pheno)),
                                    grep("PH", names(cross_file$pheno)),
                                    grep("VR", names(cross_file$pheno)),
                                    grep("FDK", names(cross_file$pheno)),
                                    grep("DON", names(cross_file$pheno)))]
# Loop through
for(i in traits){
  # Pull files
  temp1 <- list.files("./results_images")
  
  # Grep files out
  temp1 <- temp1[grep(i, temp1)]
  temp1 <- temp1[grep(".jpg", temp1)]
  temp1 <- temp1[!temp1 %in% temp1[grep("adjustment", temp1, ignore.case = TRUE)]]
  
  # Make new line 
  temp2 <- unlist(str_split(i, "_"))
  temp2[temp2=="HD"] <- "Heading Date"
  temp2[temp2=="PH"] <- "Plant Height"
  temp2[temp2=="VR"] <- "Visual Ratings"
  temp2[temp2=="FDK"] <- "Fusarium Damaged Kernels"
  temp2[temp2=="DON"] <- "Deoxynivalenol Content"
  temp2[temp2=="KIN19"] <- "Kinston, NC - 2019"
  temp2[temp2=="KIN20"] <- "Kinston, NC - 2020"
  temp2[temp2=="RAL19"] <- "Raleigh, NC - 2019"
  temp2[temp2=="RAL20"] <- "Raleigh, NC - 2020"
  temp2[temp2=="WAR19"] <- "Warsaw, VA - 2019"
  temp2[temp2=="WAR20"] <- "Warsaw, VA - 2020"
  temp2[temp2=="ME"] <- "All Environments"
  
  # Create new line for markdown
  temp3 <- c("\n",
             paste("##", temp2[1], ifelse(temp2[2]=="All Environments", "Across" ,"in"), temp2[2]))
  
  # Add to that line
  for(j in temp1){
    # Add that line
    temp4 <- c(paste("![j](\\./results_images/",j,")", sep = ""))
    
    # Bind in
    temp3 <- c(temp3, temp4)
    
    # Remove
    remove(temp4)
  }
  
  # Bind in
  markdown_content <- c(markdown_content, temp3)
  
  # Bind in new page break
  markdown_content <- c(markdown_content, "\\pagebreak")
  
  # Remove
  remove(temp1, temp2, temp3)
}

# Make a tail for the content
tail_of_content <- c(
"
## QTL Scan Information

The following table displays the output results of each scan from each environment by trait combination. Traits assessed are heading date (HD) and plant height (PH), Fusarium head blight (FHB) visual ratings (VR), Fusarium-damaged kernels (FDK), and deoxynivalenol (DON). Environments assessed are Kinston, NC 2018-2019 (KIN19) and 2019-2020 (KIN20); Raleigh, NC 2018-2019 (RAL19) and 2019-2020 (RAL20); and Warsaw, VA 2018-2019 (WAR19) and 2019-2020 (WAR20). Multi-environment scans are denoted \"ME\". The column \"QTL\" column denotes the name of the QTL, the trait to which it belongs (e.g., Hd=HD, Pht=PH, Fvr=VR, Fdk=FDK, Don=DON) and the chromosome on which the QTL is located.

\\tiny

```{r, echo = FALSE}
library(knitr)
library(rmarkdown)
suppressMessages(library(tidyverse))

a <- read.csv(\"./results_csv_files/hd_ph_vr_fdk_don_drop_one_qtl_info_no_adjustment_formatted.csv\", check.names = FALSE)
a <- a %>% 
  mutate(Environment = factor(Environment, levels = c('ME','KIN19','KIN20','RAL19','RAL20','WAR19','WAR20'))) %>%
  arrange(Trait, Environment, Chromosome, `Peak Position (cM)`) %>% 
  select(-`Left Marker`,
         -`Left Position (Mbp)`,
         -`Peak Marker`, 
         -`Peak Position (Mbp)`,
         -`Right Marker`,
         -`Right Position (Mbp)`,
         -Chromosome,
         -Trait)
knitr::kable(a, align = 'c', digits = 2)
remove(a)
```"
)

# Bind in the tail
markdown_content <- c(markdown_content, tail_of_content)

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_3.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_3.Rmd", output_format = "pdf_document")
```

## Supplemental Information 4

```{r}
# Create the Markdown content
markdown_content <- c('
---
title: \"Supplemental Information 4\"
output: 
  pdf_document:
    extra_dependencies: ["geometry"]
    latex_engine: xelatex
geometry: "left=1cm,right=1cm,top=1cm,bottom=1cm,landscape"
---

\pagenumbering{gobble}

## Description

A visualization of all 1.5-likelihood-of-odds (1.5-LOD) support intervals drawn from peak positions of significant quantitative trait locus (QTL) identified for plant height (PH), heading date (HD), Fusarium head blight (FHB) visual ratings (VR), Fusarium-damaged kernels (FDK), and deoxynivalenol (DON) content. This is a naive model that does not include marker covariates. Both multi-environment (ME) and within-environment scans were mapped in this image. Within-environment scans included the Cunningham Research Station in Kinston, North Carolina in 2019 (KIN19) and 2020 (KIN20); the Lake Wheeler Field Laboratory in Raleigh, North Carolina in 2019 (RAL19) and 2020 (RAL20), and the Eastern Agricultural Research and Extension Center in Warsaw Virginia in 2019 (WAR19) and 2020 (WAR20). Support intervals are denoted by bars to the right of linkage groups. The y-axis displays a scale for length of linkage groups in centimorgans (cM). Each linkage group is displayed as a series of points (markers) and a connecting line (distance between markers). The length and position of the bar denotes the length and position of the QTL on the resultant linkage group, indicated by the title above the linkage group (e.g., 1B). The color of the corresponding support interval denotes the corresponding scan to which that interval belongs (e.g., heading date across environments = HD_ME). Markers labeled by orange triangles denote peak QTL positions used as covariates in scans for visual rating of Fusarium head blight infection, Fusarium-damaged kernels, and DON content. Covariate markers were selected based on their repeated occurrence across scans and their appearance in the multi-environment scans of both plant height and heading date.

\\pagebreak

![](\\./results_images/support_intervals_hd_ph_vr_fdk_don_unadjusted.jpg)

')

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_4.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_4.Rmd", output_format = "pdf_document")
```

## Supplemental Information 5

```{r}
# Create the Markdown content
markdown_content <- c("
---
title: \"Supplemental Information 5\"
output: 
  pdf_document:
    extra_dependencies: [\"geometry\"]
    latex_engine: xelatex
geometry: landscape
---

## Description

Interval mapping (IM) and multiple-quantitative-trait-locus mapping (MQM) scans for Fusarium head blight (FHB) disease resistance traits visual rating (VR), Fusarium-damaged kernels (FDK), and deoxynivalenol (DON) content quantitative trait loci (QTL) with heading date and plant height marker covariates. Environments assessed include:  Kinston, NC 2019 (KIN19) and 2020 (KIN20); Raleigh, NC 2019 (RAL19) and 2020 (RAL20); Warsaw, VA 2019 (WAR19) and 2020 (WAR20); and the multi-environment (ME). The number following MQM titles indicates which round of MQM the scan belongs to (e.g., MQM 2 is the second round of multiple QTL mapping). The y-axis displays the likelihood-of-odds (LOD) score of every position across the genome. The dotted line denotes the 1,000-permutation significance threshold at alpha = 0.05. If the significance threshold is not displayed within the graph, all peaks detected in the QTL scan were below the significance threshold. This is usually apparent in the last MQM scan performed. The x-axis displays each linkage group, designated by their corresponding chromosome names (e.g., 1A, 1B, 1D, etc.). The rug of hash marks denotes the cM position of each marker in the recombination map. All information regarding location, LOD and effect appears at the end of the document.

\\pagebreak

")

for(i in traits[c(grep("VR", traits),
                  grep("FDK", traits),
                  grep("DON", traits))]){
  # Pull files
  temp1 <- list.files("./results_images")
  
  # Grep files out
  temp1 <- temp1[grep(i, temp1)]
  temp1 <- temp1[grep(".jpg", temp1)]
  temp1 <- temp1[grep("adjustment", temp1, ignore.case = TRUE)]
  
  # Make new line 
  temp2 <- unlist(str_split(i, "_"))
  temp2[temp2=="VR"] <- "Visual Ratings"
  temp2[temp2=="FDK"] <- "Fusarium Damaged Kernels"
  temp2[temp2=="DON"] <- "Deoxynivalenol Content"
  temp2[temp2=="KIN19"] <- "Kinston, NC - 2019"
  temp2[temp2=="KIN20"] <- "Kinston, NC - 2020"
  temp2[temp2=="RAL19"] <- "Raleigh, NC - 2019"
  temp2[temp2=="RAL20"] <- "Raleigh, NC - 2020"
  temp2[temp2=="WAR19"] <- "Warsaw, VA - 2019"
  temp2[temp2=="WAR20"] <- "Warsaw, VA - 2020"
  temp2[temp2=="ME"] <- "All Environments"
  
  # Create new line for markdown
  temp3 <- c("\n",
             paste("##", temp2[1], ifelse(temp2[2]=="All Environments", "Across" ,"in"), temp2[2]))
  
  # Add to that line
  for(j in temp1){
    # Add that line
    temp4 <- c(paste("![j](\\./results_images/",j,")", sep = ""))
    
    # Bind in
    temp3 <- c(temp3, temp4)
    
    # Remove
    remove(temp4)
  }
  
  # Bind in
  markdown_content <- c(markdown_content, temp3)
  
  # Bind in new page break
  markdown_content <- c(markdown_content, "\\pagebreak")
  
  # Remove
  remove(temp1, temp2, temp3)
}

# Make a tail for the content
tail_of_content <- c(
"
## QTL Scan Information

The following table displays the output results of each scan from each environment-by-trait combination. Traits assessed are heading date (HD) and plant height (PH), Fusarium head blight (FHB) visual ratings (VR), Fusarium-damaged kernels (FDK), and deoxynivalenol (DON). Environments assessed are Kinston, NC 2018-2019 (KIN19) and 2019-2020 (KIN20); Raleigh, NC 2018-2019 (RAL19) and 2019-2020 (RAL20); and Warsaw, VA 2018-2019 (WAR19) and 2019-2020 (WAR20). Multi-environment scans are denoted as \"ME\". The column \"QTL\" column denotes the name of the QTL, the trait to which it belongs (e.g., Hd=HD, Pht=PH, Fvr=VR, Fdk=FDK, Don=DON) and the chromosome on which the QTL is located.

\\tiny

```{r, echo = FALSE}
library(knitr)
library(rmarkdown)
suppressMessages(library(tidyverse))

a <- read.csv(\"./results_csv_files/vr_fdk_don_drop_one_qtl_info_with_adjustment_formatted.csv\", check.names = FALSE)
a <- a %>% 
  mutate(Environment = factor(Environment, levels = c('ME','KIN19','KIN20','RAL19','RAL20','WAR19','WAR20'))) %>%
  arrange(Trait, Environment, Chromosome, `Peak Position (cM)`) %>% 
  select(-`Left Marker`,
         -`Left Position (Mbp)`,
         -`Peak Marker`, 
         -`Peak Position (Mbp)`,
         -`Right Marker`,
         -`Right Position (Mbp)`,
         -Chromosome,
         -Trait)
knitr::kable(a, align = 'c', digits = 2)
remove(a)
```"
)

# Bind in
markdown_content <- c(markdown_content, tail_of_content)

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_5.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_5.Rmd", output_format = "pdf_document")
```

## Supplemental Information 6

```{r}
# Create the Markdown content
markdown_content <- c('
---
title: \"Supplemental Information 6\"
output: 
  pdf_document:
    extra_dependencies: ["geometry"]
    latex_engine: xelatex
geometry: "left=1cm,right=1cm,top=1cm,bottom=1cm,landscape"
---

\pagenumbering{gobble}

## Description

A visualization of all 1.5-likelihood-of-odds (1.5-LOD) support intervals drawn from peak positions of significant quantitative trait locus (QTL) identified for Fusarium head blight (FHB) reaction traits visual rating (VR), Fusarium-damaged kernels (FDK) and deoxynivalenol content (DON). Both multi-environment (ME) and within-environment scans were mapped in this image. Within-environment scans included the Cunningham Research Station in Kinston, North Carolina in 2019 (KIN2019) and 2020 (KIN2020); the Lake Wheeler Field Laboratory in Raleigh, North Carolina in 2019 (LW2019) and 2020 (LW2020), and the Eastern Agricultural Research and Extension Center in Warsaw, Virginia in 2019 (VIR2019) and 2020 (VIR2020). Support intervals are denoted by bars to the right of linkage groups. The y-axis displays a scale for length of linkage groups in centimorgans (cM). Each linkage group is displayed as a series of points (markers) and a connecting line (distance between markers). The length and position of the bar denotes the length and position of the QTL on the resultant linkage group, which is indicated by the title above the linkage group (e.g., 1A). The color of the corresponding support interval denotes the corresponding scan to which that interval belongs (e.g., visual rating across environments = VR_ME). Markers labeled by orange triangles denote peak QTL positions used as covariates in scans for visual rating of Fusarium head blight infection, Fusarium-damaged kernels, and DON content.

\\pagebreak

![](\\./results_images/support_intervals_vr_fdk_don_with_adjustment.jpg)

')

# Write the Markdown content to a file
writeLines(markdown_content, "supplemental_information_6.Rmd")

# Render the Markdown file to PDF
rmarkdown::render("supplemental_information_6.Rmd", output_format = "pdf_document")
```

## Move all supplemental files to relevant folders 

```{r}
# Create directory
target_directory <- paste(getwd(), "supplemental_information", sep = "/")
dir.create(target_directory, showWarnings = FALSE)

# Get a list of files that are images
files <- list.files()[grep("supplemental_information_", list.files(), ignore.case = TRUE)]

# Move into folder
for(i in files){
  # Get working directory
  temp1 <- paste(getwd(), i, sep = "/")
  
  # Get target directory 
  temp2 <- paste(target_directory, i, sep = "/")
  
  # Move the file
  file.rename(from = temp1,
              to = temp2)
  
  # Remove
  remove(temp1, temp2)
}
```

# Save analysis image

```{r}
# Save image
save.image("Final_Analysis.RData")
```